###############################################################################
#                                                                             #
#                                                       24/Jun/2013  09:03:14 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430                                                     #
#    Source file   =  E:\Dooya\dooya_dev\DU0106\Source\smoke\src\lib\spi.c    #
#    Command line  =  E:\Dooya\dooya_dev\DU0106\Source\smoke\src\lib\spi.c    #
#                     -lC E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\Debug\Li #
#                     st\ -lA E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\Debu #
#                     g\List\ -o E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\D #
#                     ebug\Obj\ --no_cse --no_unroll --no_inline              #
#                     --no_code_motion --no_tbaa --debug -D__MSP430G2433__    #
#                     -e --double=32 --dlib_config "C:\Program Files\IAR      #
#                     Systems\Embedded Workbench 6.4                          #
#                     Evaluation\430\LIB\DLIB\dl430fn.h" -I                   #
#                     E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\..\src\app\  #
#                     -I E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\..\src\bs #
#                     p\ -I E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\..\src #
#                     \lib\ -I E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\..\ #
#                     src\Radio\ -I E:\Dooya\dooya_dev\DU0106\Source\smoke\ia #
#                     r\..\src\Radio\CC1101\ -I E:\Dooya\dooya_dev\DU0106\Sou #
#                     rce\smoke\iar\..\src\Radio\Si4455\ -Ol                  #
#    List file     =  E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\Debug\List\s #
#                     pi.lst                                                  #
#    Object file   =  E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\Debug\Obj\sp #
#                     i.r43                                                   #
#                                                                             #
#                                                                             #
###############################################################################

E:\Dooya\dooya_dev\DU0106\Source\smoke\src\lib\spi.c
      1          #include <msp430.h>

   \                                 In  segment DATA16_AN, at 0x1
   \   unsigned char volatile IE2
   \                     IE2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x3
   \   unsigned char volatile IFG2
   \                     IFG2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x21
   \   unsigned char volatile P1OUT
   \                     P1OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x26
   \   unsigned char volatile P1SEL
   \                     P1SEL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x41
   \   unsigned char volatile P1SEL2
   \                     P1SEL2:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x60
   \   unsigned char volatile UCA0CTL0
   \                     UCA0CTL0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x61
   \   unsigned char volatile UCA0CTL1
   \                     UCA0CTL1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x62
   \   unsigned char volatile UCA0BR0
   \                     UCA0BR0:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x63
   \   unsigned char volatile UCA0BR1
   \                     UCA0BR1:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x64
   \   unsigned char volatile UCA0MCTL
   \                     UCA0MCTL:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x66
   \   unsigned char const volatile UCA0RXBUF
   \                     UCA0RXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x67
   \   unsigned char volatile UCA0TXBUF
   \                     UCA0TXBUF:
   \   000000                DS8 1
      2          #include "spi.h"
      3          
      4          //#define Soft_SPI
      5          #define SPI_SOMI		BIT1
      6          #define SPI_SIMO		BIT2
      7          #define SPI_CLK			BIT4
      8          #define SPI_STE			BIT5
      9          
     10          

   \                                 In  segment CODE, align 2
     11          void spi_init(void)
   \                     spi_init:
     12          {
     13          	P1SEL = BIT1 + BIT2 + BIT4;
   \   000000   F24016002600 MOV.B   #0x16, &0x26
     14          	P1SEL2 = BIT1 + BIT2 + BIT4;
   \   000006   F24016004100 MOV.B   #0x16, &0x41
     15          	
     16          	UCA0CTL0 |= UCCKPL + UCMSB + UCMST + UCSYNC;  					// 3-pin, 8-bit SPI master
   \   00000C   F2D069006000 BIS.B   #0x69, &0x60
     17          	UCA0CTL1 |= UCSSEL_2;                     						// SMCLK
   \   000012   F2D080006100 BIS.B   #0x80, &0x61
     18          	
     19          	UCA0BR0 |= 0x02;                          						// /2
   \   000018   E2D36200     BIS.B   #0x2, &0x62
     20          	UCA0BR1 = 0;
   \   00001C   C2436300     MOV.B   #0x0, &0x63
     21          	
     22          	UCA0MCTL = 0;                             						// No modulation
   \   000020   C2436400     MOV.B   #0x0, &0x64
     23          	UCA0CTL1 &= ~UCSWRST;                     						// **Initialize USCI state machine**
   \   000024   D2C36100     BIC.B   #0x1, &0x61
     24          }
   \   000028   3041         RET
   \   00002A                REQUIRE P1SEL
   \   00002A                REQUIRE P1SEL2
   \   00002A                REQUIRE UCA0CTL0
   \   00002A                REQUIRE UCA0CTL1
   \   00002A                REQUIRE UCA0BR0
   \   00002A                REQUIRE UCA0BR1
   \   00002A                REQUIRE UCA0MCTL
     25          

   \                                 In  segment CODE, align 2
     26          void spi_isr_enable(void)
   \                     spi_isr_enable:
     27          {
     28          	IE2 |= UCA0RXIE;                          						// Enable USCI0 RX interrupt
   \   000000   D2D30100     BIS.B   #0x1, &0x1
     29          }
   \   000004   3041         RET
   \   000006                REQUIRE IE2
     30          

   \                                 In  segment CODE, align 2
     31          void spi_cs_enable(void)
   \                     spi_cs_enable:
     32          {
     33          	P1OUT &=~SPI_STE;
   \   000000   F2C020002100 BIC.B   #0x20, &0x21
     34          }
   \   000006   3041         RET
   \   000008                REQUIRE P1OUT
     35          

   \                                 In  segment CODE, align 2
     36          void spi_cs_disable(void)
   \                     spi_cs_disable:
     37          {
     38          	P1OUT |= SPI_STE;
   \   000000   F2D020002100 BIS.B   #0x20, &0x21
     39          }
   \   000006   3041         RET
   \   000008                REQUIRE P1OUT
     40          

   \                                 In  segment CODE, align 2
     41          void Spi_Write_Byte(unsigned char data)
   \                     Spi_Write_Byte:
     42          {
     43          	UCA0TXBUF = data;
   \   000000   C24C6700     MOV.B   R12, &0x67
     44          	while (!(IFG2 & UCA0TXIFG));
   \                     ??Spi_Write_Byte_0:
   \   000004   E2B30300     BIT.B   #0x2, &0x3
   \   000008   FD2B         JNC     ??Spi_Write_Byte_0
     45          }
   \   00000A   3041         RET
   \   00000C                REQUIRE UCA0TXBUF
   \   00000C                REQUIRE IFG2
     46          
     47          //spi read byte

   \                                 In  segment CODE, align 2
     48          unsigned char Spi_Read_Byte(void)
   \                     Spi_Read_Byte:
     49          {
     50          	Spi_Write_Byte(0x00);
   \   000000   4C43         MOV.B   #0x0, R12
   \   000002   B012....     CALL    #Spi_Write_Byte
     51          	return UCA0RXBUF;
   \   000006   5C426600     MOV.B   &0x66, R12
   \   00000A   3041         RET
   \   00000C                REQUIRE UCA0RXBUF
     52          }
     53          

   \                                 In  segment CODE, align 2
     54          unsigned char spi_readwrite(unsigned char data)
   \                     spi_readwrite:
     55          {
     56          	Spi_Write_Byte(data);
   \   000000   B012....     CALL    #Spi_Write_Byte
     57          	return UCA0RXBUF;
   \   000004   5C426600     MOV.B   &0x66, R12
   \   000008   3041         RET
   \   00000A                REQUIRE UCA0RXBUF
     58          }
     59          

   \                                 In  segment CODE, align 2
     60          void spi_write_buf(unsigned char *pdata, unsigned char len)
   \                     spi_write_buf:
   \                     ??spi_write_buf_0:
     61          {
     62          	while(len-- < 1)
   \   000000   4E4D         MOV.B   R13, R14
   \   000002   4D4E         MOV.B   R14, R13
   \   000004   7D53         ADD.B   #0xff, R13
   \   000006   5E93         CMP.B   #0x1, R14
   \   000008   062C         JC      ??spi_write_buf_2
     63          	{
     64          		UCA0TXBUF = *pdata;
   \   00000A   E24C6700     MOV.B   @R12, &0x67
     65          		while (!(IFG2 & UCA0TXIFG));
   \                     ??spi_write_buf_1:
   \   00000E   E2B30300     BIT.B   #0x2, &0x3
   \   000012   F62F         JC      ??spi_write_buf_0
   \   000014   FC3F         JMP     ??spi_write_buf_1
     66          	}
     67          }
   \                     ??spi_write_buf_2:
   \   000016   3041         RET
   \   000018                REQUIRE UCA0TXBUF
   \   000018                REQUIRE IFG2
     68          

   \                                 In  segment CODE, align 2
     69          void spi_read_buf(unsigned char *pdata, unsigned char len)
   \                     spi_read_buf:
     70          {
   \   000000   083C         JMP     ??spi_read_buf_2
     71          	while(len-- < 1)
     72          	{
     73          		UCA0TXBUF = 0xFF;
   \                     ??spi_read_buf_1:
   \   000002   F2436700     MOV.B   #0xff, &0x67
     74          		while (!(IFG2 & UCA0TXIFG));
   \                     ??spi_read_buf_0:
   \   000006   E2B30300     BIT.B   #0x2, &0x3
   \   00000A   FD2B         JNC     ??spi_read_buf_0
     75          		*pdata = UCA0RXBUF;
   \   00000C   DC4266000000 MOV.B   &0x66, 0(R12)
     76          	}
   \                     ??spi_read_buf_2:
   \   000012   4E4D         MOV.B   R13, R14
   \   000014   4D4E         MOV.B   R14, R13
   \   000016   7D53         ADD.B   #0xff, R13
   \   000018   5E93         CMP.B   #0x1, R14
   \   00001A   F32B         JNC     ??spi_read_buf_1
     77          }
   \   00001C   3041         RET
   \   00001E                REQUIRE UCA0TXBUF
   \   00001E                REQUIRE IFG2
   \   00001E                REQUIRE UCA0RXBUF
     78          /*
     79          #pragma vector=USCIAB0RX_VECTOR
     80          __interrupt void USCIA0RX_ISR(void)
     81          {
     82          	volatile unsigned int i;
     83          
     84          	while (!(IFG2 & UCA0TXIFG));              	// USCI_A0 TX buffer ready?
     85          	
     86          	if (UCA0RXBUF == 0x00)
     87          	{
     88          		P1OUT &=~BIT2;
     89          	}
     90          }
     91          */

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       2  Spi_Read_Byte
            2 -> Spi_Write_Byte
       2  Spi_Write_Byte
       2  spi_cs_disable
       2  spi_cs_enable
       2  spi_init
       2  spi_isr_enable
       2  spi_read_buf
       2  spi_readwrite
            2 -> Spi_Write_Byte
       2  spi_write_buf


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       1  IE2
       1  IFG2
       1  P1OUT
       1  P1SEL
       1  P1SEL2
      12  Spi_Read_Byte
      12  Spi_Write_Byte
       1  UCA0BR0
       1  UCA0BR1
       1  UCA0CTL0
       1  UCA0CTL1
       1  UCA0MCTL
       1  UCA0RXBUF
       1  UCA0TXBUF
       8  spi_cs_disable
       8  spi_cs_enable
      42  spi_init
       6  spi_isr_enable
      30  spi_read_buf
      10  spi_readwrite
      24  spi_write_buf

 
 152 bytes in segment CODE
  12 bytes in segment DATA16_AN
 
 152 bytes of CODE memory
   0 bytes of DATA memory (+ 12 bytes shared)

Errors: none
Warnings: none
