###############################################################################
#                                                                             #
#                                                       24/Jun/2013  16:18:28 #
# IAR C/C++ Compiler V5.50.1.20465/W32, Evaluation edition for MSP430         #
# Copyright 1996-2012 IAR Systems AB.                                         #
#                                                                             #
#    __rt_version  =  3                                                       #
#    __double_size =  32                                                      #
#    __reg_r4      =  free                                                    #
#    __reg_r5      =  free                                                    #
#    __pic         =  no                                                      #
#    __core        =  430                                                     #
#    Source file   =  E:\Dooya\dooya_dev\DU0106\Source\smoke\src\radio\CC1101 #
#                     \RfTranceiver.c                                         #
#    Command line  =  E:\Dooya\dooya_dev\DU0106\Source\smoke\src\radio\CC1101 #
#                     \RfTranceiver.c -lC E:\Dooya\dooya_dev\DU0106\Source\sm #
#                     oke\iar\Debug\List\ -lA E:\Dooya\dooya_dev\DU0106\Sourc #
#                     e\smoke\iar\Debug\List\ -o                              #
#                     E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\Debug\Obj\   #
#                     --no_cse --no_unroll --no_inline --no_code_motion       #
#                     --no_tbaa --debug -D__MSP430G2433__ -e --double=32      #
#                     --dlib_config "C:\Program Files\IAR Systems\Embedded    #
#                     Workbench 6.4 Evaluation\430\LIB\DLIB\dl430fn.h" -I     #
#                     E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\..\src\app\  #
#                     -I E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\..\src\bs #
#                     p\ -I E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\..\src #
#                     \lib\ -I E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\..\ #
#                     src\Radio\ -I E:\Dooya\dooya_dev\DU0106\Source\smoke\ia #
#                     r\..\src\Radio\CC1101\ -I E:\Dooya\dooya_dev\DU0106\Sou #
#                     rce\smoke\iar\..\src\Radio\Si4455\ -Ol                  #
#    List file     =  E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\Debug\List\R #
#                     fTranceiver.lst                                         #
#    Object file   =  E:\Dooya\dooya_dev\DU0106\Source\smoke\iar\Debug\Obj\Rf #
#                     Tranceiver.r43                                          #
#                                                                             #
#                                                                             #
###############################################################################

E:\Dooya\dooya_dev\DU0106\Source\smoke\src\radio\CC1101\RfTranceiver.c
      1          /* ********************************************************************** *
      2           *                           DOOYA Company                                *
      3           * The Tree of the NetWork Design Basic CC1101                            *
      4           * Compiler : MPLAB IDE V8.66                                             *
      5           * Crystal  : 32MHZ                                                       *
      6           * MCU      : PIC24FJ64GA002                                              *
      7           * FileName : RfTranceiver.c                                              *
      8           * Author   : Softli                                                      *
      9           * Address  : NingBo                                                      *
     10           * Time     : 2012-12-21                                                  *
     11           * Version  : V1.0                                                        *
     12           * Testing                                                                *
     13           * ********************************************************************** */
     14           
     15           #define _Tranceiver_Global_
     16           
     17          #include "msp430.h"

   \                                 In  segment DATA16_AN, at 0x20
   \   unsigned char const volatile P1IN
   \                     P1IN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x21
   \   unsigned char volatile P1OUT
   \                     P1OUT:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x22
   \   unsigned char volatile P1DIR
   \                     P1DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x28
   \   unsigned char const volatile P2IN
   \                     P2IN:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2a
   \   unsigned char volatile P2DIR
   \                     P2DIR:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2b
   \   unsigned char volatile P2IFG
   \                     P2IFG:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2c
   \   unsigned char volatile P2IES
   \                     P2IES:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x2d
   \   unsigned char volatile P2IE
   \                     P2IE:
   \   000000                DS8 1
     18          #include "spi.h"
     19          #include "RfTranceiver.h"

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \   unsigned char RxBuf[20]
   \                     RxBuf:
   \   000000                DS8 20

   \                                 In  segment DATA16_C, align 2, align-sorted
   \   unsigned char *const ptrRxBufOver
   \                     ptrRxBufOver:
   \   000000   ....         DC16 RxBuf + 14H

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \   unsigned char volatile *ptrRxBufWrite
   \                     ptrRxBufWrite:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
   \   unsigned char *ptrRxBufRead
   \                     ptrRxBufRead:
   \   000000                DS8 2
     20          #include "stdio.h"
     21           
     22           //routine check counter 

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     23           static unsigned char          RoutineCounter = 0;
   \                     RoutineCounter:
   \   000000                DS8 1
     24           //cc1101 reset call back function  

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     25           static RfResetCallBack        pRfResetCallBack = NULL;
   \                     pRfResetCallBack:
   \   000000                DS8 2
     26           

   \                                 In  segment DATA16_I, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     27           unsigned char dat[2] = {0xB1, 0x01};
   \                     dat:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for dat>`

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     28           unsigned char sys_send = 0;
   \                     sys_send:
   \   000000                DS8 1
     29           //extend interrupt0 insert address
     30          // void __attribute__((interrupt,auto_psv)) _INT1Interrupt(void)
     31          
     32          /* ============================================ *
     33           *    register cc1101 reset callback function   *
     34           * ============================================ */

   \                                 In  segment CODE, align 2
     35           void CC1101_ResetCallBackRegister(RfResetCallBack pCallBack)
   \                     CC1101_ResetCallBackRegister:
     36           {
     37              pRfResetCallBack=pCallBack;
   \   000000   824C....     MOV.W   R12, &pRfResetCallBack
     38           }
   \   000004   3041         RET
     39           
     40          /* ============================================ *
     41           *        write strobe command to cc11001       *
     42           * ============================================ */

   \                                 In  segment CODE, align 2
     43           void CC1101_Strobe(unsigned char stro)
   \                     CC1101_Strobe:
     44           {
     45          //    unsigned char Rex;
     46              //save break point
     47          //    StoreAndDisRfInterrupt(Rex);
     48              //enable stabilize
     49          	Enable_CC1101;
   \   000000   F2C020002100 BIC.B   #0x20, &0x21
     50          	//wait for cc1101
     51          	while(CC1101_Check_So);
   \                     ??CC1101_Strobe_0:
   \   000006   E2B32000     BIT.B   #0x2, &0x20
   \   00000A   FD2F         JC      ??CC1101_Strobe_0
     52          	//write strobe command to register 
     53          	spi_readwrite(stro); 
   \   00000C   B012....     CALL    #spi_readwrite
     54              //disable cc1101 
     55          	Disable_CC1101;
   \   000010   F2D020002100 BIS.B   #0x20, &0x21
     56              //resume break point 
     57          //    RestoreRfInterrupt(Rex);
     58           }
   \   000016   3041         RET
   \   000018                REQUIRE P1OUT
   \   000018                REQUIRE P1IN
     59           
     60          /* ============================================ *
     61           *            write register to cc1101          *
     62           * ============================================ */

   \                                 In  segment CODE, align 2
     63           void CC1101_Write_Reg(unsigned char addr,unsigned char value)
   \                     CC1101_Write_Reg:
     64           {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4D         MOV.B   R13, R10
     65          //    unsigned char Rex;
     66              //save break point 
     67              StoreAndDisRfInterrupt(Rex);
   \   000004   D2C32D00     BIC.B   #0x1, &0x2d
     68              //enable cc1101 
     69              Enable_CC1101; 
   \   000008   F2C020002100 BIC.B   #0x20, &0x21
     70          	//wait for ....
     71              while(CC1101_Check_So);
   \                     ??CC1101_Write_Reg_0:
   \   00000E   E2B32000     BIT.B   #0x2, &0x20
   \   000012   FD2F         JC      ??CC1101_Write_Reg_0
     72          	//write address of register 
     73          	spi_readwrite(addr);  
   \   000014   B012....     CALL    #spi_readwrite
     74          	//write value to register 
     75          	spi_readwrite(value); 
   \   000018   4C4A         MOV.B   R10, R12
   \   00001A   B012....     CALL    #spi_readwrite
     76          	//disable cc1101 
     77          	Disable_CC1101;
   \   00001E   F2D020002100 BIS.B   #0x20, &0x21
     78              //resume break point 
     79              RestoreRfInterrupt(Rex);
   \   000024   D2D32D00     BIS.B   #0x1, &0x2d
     80           }
   \   000028   3A41         POP.W   R10
   \   00002A   3041         RET
   \   00002C                REQUIRE P2IE
   \   00002C                REQUIRE P1OUT
   \   00002C                REQUIRE P1IN
     81             
     82          /* ============================================ *
     83           *            write many register once          *
     84           * ============================================ */

   \                                 In  segment CODE, align 2
     85           void CC1101_Write_Burst_Reg(unsigned char addr,unsigned char *buffer,unsigned char count)
   \                     CC1101_Write_Burst_Reg:
     86           {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0B4D         MOV.W   R13, R11
   \   000006   4A4E         MOV.B   R14, R10
     87              unsigned char temp;
     88              //save break point 
     89              StoreAndDisRfInterrupt(Rex);
   \   000008   D2C32D00     BIC.B   #0x1, &0x2d
     90          	//write burst set 1
     91          	temp=addr|WRITE_BURST;
   \   00000C   7CD04000     BIS.B   #0x40, R12
     92          	//enable cc1101 
     93          	Enable_CC1101;
   \   000010   F2C020002100 BIC.B   #0x20, &0x21
     94          	//wait for....
     95          	while(CC1101_Check_So);
   \                     ??CC1101_Write_Burst_Reg_0:
   \   000016   E2B32000     BIT.B   #0x2, &0x20
   \   00001A   FD2F         JC      ??CC1101_Write_Burst_Reg_0
     96          	//write address
     97          	spi_readwrite(temp);
   \   00001C   B012....     CALL    #spi_readwrite
     98          	//write data bytes
     99              spi_write_buf(buffer,count);
   \   000020   4D4A         MOV.B   R10, R13
   \   000022   0C4B         MOV.W   R11, R12
   \   000024   B012....     CALL    #spi_write_buf
    100              //disable cc1101 
    101          	Disable_CC1101;
   \   000028   F2D020002100 BIS.B   #0x20, &0x21
    102              //resume break point 
    103              RestoreRfInterrupt(Rex);
   \   00002E   D2D32D00     BIS.B   #0x1, &0x2d
    104           }
   \   000032   3B41         POP.W   R11
   \   000034   3A41         POP.W   R10
   \   000036   3041         RET
   \   000038                REQUIRE P2IE
   \   000038                REQUIRE P1OUT
   \   000038                REQUIRE P1IN
    105           
    106          /* ============================================ * 
    107           *           read single register once          * 
    108           * ============================================ */

   \                                 In  segment CODE, align 2
    109           unsigned char CC1101_Read_Reg(unsigned char addr) 
   \                     CC1101_Read_Reg:
    110           {
    111          	unsigned char value,temp;
    112          //    unsigned char Rex;
    113              //save break point 
    114              StoreAndDisRfInterrupt(Rex);
   \   000000   D2C32D00     BIC.B   #0x1, &0x2d
    115              //re-build address
    116          	temp=addr|READ_SINGLE; 
   \   000004   7CD08000     BIS.B   #0x80, R12
    117          	//enable cc1101
    118          	Enable_CC1101;
   \   000008   F2C020002100 BIC.B   #0x20, &0x21
    119          	//wait for...
    120          	while(CC1101_Check_So);
   \                     ??CC1101_Read_Reg_0:
   \   00000E   E2B32000     BIT.B   #0x2, &0x20
   \   000012   FD2F         JC      ??CC1101_Read_Reg_0
    121          	//write address
    122          	spi_readwrite(temp);
   \   000014   B012....     CALL    #spi_readwrite
    123          	//read data byte
    124          	value=spi_readwrite(0xff);
   \   000018   7C43         MOV.B   #0xff, R12
   \   00001A   B012....     CALL    #spi_readwrite
    125          	//disable cc1101 
    126          	Disable_CC1101;
   \   00001E   F2D020002100 BIS.B   #0x20, &0x21
    127              //resume break point 
    128              RestoreRfInterrupt(Rex);
   \   000024   D2D32D00     BIS.B   #0x1, &0x2d
    129          	return value;
   \   000028   3041         RET
   \   00002A                REQUIRE P2IE
   \   00002A                REQUIRE P1OUT
   \   00002A                REQUIRE P1IN
    130           }
    131          
    132          /* ============================================ *
    133           *           read read register more once       *
    134           * ============================================ */

   \                                 In  segment CODE, align 2
    135           void CC1101_Read_Burst_Reg(unsigned char count)
   \                     CC1101_Read_Burst_Reg:
    136           {  
    137              unsigned char temp;
    138              StoreAndDisRfInterrupt(Rex);
   \   000000   D2C32D00     BIC.B   #0x1, &0x2d
    139              //re-build net address
    140          	temp=cc1101_RXFIFO|READ_BURST;
   \   000004   7C43         MOV.B   #0xff, R12
    141          	//enable cc1101 
    142          	Enable_CC1101;
   \   000006   F2C020002100 BIC.B   #0x20, &0x21
    143          	//wait for ...
    144          	while(CC1101_Check_So);
   \                     ??CC1101_Read_Burst_Reg_0:
   \   00000C   E2B32000     BIT.B   #0x2, &0x20
   \   000010   FD2F         JC      ??CC1101_Read_Burst_Reg_0
    145          	//write address
    146          	spi_readwrite(temp);
   \   000012   B012....     CALL    #spi_readwrite
    147          	//从CC1101 RX FIFO 中读取数据
    148          //	APIReadArrayBytes(count);
    149              //disable cc1101 
    150          	Disable_CC1101;
   \   000016   F2D020002100 BIS.B   #0x20, &0x21
    151              //resume break point 
    152              RestoreRfInterrupt(Rex);
   \   00001C   D2D32D00     BIS.B   #0x1, &0x2d
    153           }
   \   000020   3041         RET
   \   000022                REQUIRE P2IE
   \   000022                REQUIRE P1OUT
   \   000022                REQUIRE P1IN
    154           
    155          /* ============================================ *
    156           *     读状态积存器  burst 位应该为 --> 1      *
    157           * ============================================ */

   \                                 In  segment CODE, align 2
    158           unsigned char CC1101_Read_Status(unsigned char addr) 
   \                     CC1101_Read_Status:
    159           {
    160             	unsigned char value,temp;
    161          //    unsigned char Rex;
    162              StoreAndDisRfInterrupt(Rex);
   \   000000   D2C32D00     BIC.B   #0x1, &0x2d
    163              //re-build new address
    164          	temp=addr|READ_BURST;
   \   000004   7CD0C000     BIS.B   #0xc0, R12
    165          	//enable cc1101 
    166          	Enable_CC1101;
   \   000008   F2C020002100 BIC.B   #0x20, &0x21
    167          	//wait for ...
    168          	while(CC1101_Check_So);
   \                     ??CC1101_Read_Status_0:
   \   00000E   E2B32000     BIT.B   #0x2, &0x20
   \   000012   FD2F         JC      ??CC1101_Read_Status_0
    169          	//write address...
    170          	spi_readwrite(temp);
   \   000014   B012....     CALL    #spi_readwrite
    171          	//read data byte 
    172          	value=spi_readwrite(0xff);
   \   000018   7C43         MOV.B   #0xff, R12
   \   00001A   B012....     CALL    #spi_readwrite
    173          	//disable cc1101 
    174          	Disable_CC1101;
   \   00001E   F2D020002100 BIS.B   #0x20, &0x21
    175              //resume break point 
    176              RestoreRfInterrupt(Rex);
   \   000024   D2D32D00     BIS.B   #0x1, &0x2d
    177              //return read data 
    178          	return value;
   \   000028   3041         RET
   \   00002A                REQUIRE P2IE
   \   00002A                REQUIRE P1OUT
   \   00002A                REQUIRE P1IN
    179           }
    180          
    181          /* ============================================ *
    182           *           CC1101 Setting Parameter           *
    183           * ============================================ */

   \                                 In  segment CODE, align 2
    184           void CC1101_Rf_Write_Settings(void)
   \                     CC1101_Rf_Write_Settings:
    185           {
    186              //CC1100 FSCTRL
    187          	CC1101_Write_Reg(cc1101_FSCTRL0,FSCTRL2);
   \   000000   4D43         MOV.B   #0x0, R13
   \   000002   7C400C00     MOV.B   #0xc, R12
   \   000006   B012....     CALL    #CC1101_Write_Reg
    188              CC1101_Write_Reg(cc1101_FSCTRL1,FSCTRL1);
   \   00000A   7D400C00     MOV.B   #0xc, R13
   \   00000E   7C400B00     MOV.B   #0xb, R12
   \   000012   B012....     CALL    #CC1101_Write_Reg
    189          	CC1101_Write_Reg(cc1101_FSCTRL0,FSCTRL0);
   \   000016   4D43         MOV.B   #0x0, R13
   \   000018   7C400C00     MOV.B   #0xc, R12
   \   00001C   B012....     CALL    #CC1101_Write_Reg
    190          	//MDMCFG
    191              CC1101_Write_Reg(cc1101_MDMCFG4,MDMCFG4);
   \   000020   7D402D00     MOV.B   #0x2d, R13
   \   000024   7C401000     MOV.B   #0x10, R12
   \   000028   B012....     CALL    #CC1101_Write_Reg
    192          	CC1101_Write_Reg(cc1101_MDMCFG3,MDMCFG3);
   \   00002C   7D403B00     MOV.B   #0x3b, R13
   \   000030   7C401100     MOV.B   #0x11, R12
   \   000034   B012....     CALL    #CC1101_Write_Reg
    193          	CC1101_Write_Reg(cc1101_MDMCFG2,MDMCFG2);
   \   000038   7D401300     MOV.B   #0x13, R13
   \   00003C   7C401200     MOV.B   #0x12, R12
   \   000040   B012....     CALL    #CC1101_Write_Reg
    194          	CC1101_Write_Reg(cc1101_MDMCFG1,MDMCFG1);
   \   000044   7D402300     MOV.B   #0x23, R13
   \   000048   7C401300     MOV.B   #0x13, R12
   \   00004C   B012....     CALL    #CC1101_Write_Reg
    195          	CC1101_Write_Reg(cc1101_MDMCFG0,MDMCFG0);
   \   000050   7D43         MOV.B   #0xff, R13
   \   000052   7C401400     MOV.B   #0x14, R12
   \   000056   B012....     CALL    #CC1101_Write_Reg
    196          	CC1101_Write_Reg(cc1101_FIFOTHR,FIFOTHR);
   \   00005A   7D400700     MOV.B   #0x7, R13
   \   00005E   7C400300     MOV.B   #0x3, R12
   \   000062   B012....     CALL    #CC1101_Write_Reg
    197          	//DEVIATN 
    198          	CC1101_Write_Reg(cc1101_DEVIATN,DEVIATN);
   \   000066   7D406200     MOV.B   #0x62, R13
   \   00006A   7C401500     MOV.B   #0x15, R12
   \   00006E   B012....     CALL    #CC1101_Write_Reg
    199          	//FREND
    200          	CC1101_Write_Reg(cc1101_FREND1,FREND1);
   \   000072   7D40B600     MOV.B   #0xb6, R13
   \   000076   7C402100     MOV.B   #0x21, R12
   \   00007A   B012....     CALL    #CC1101_Write_Reg
    201          	CC1101_Write_Reg(cc1101_FREND0,FREND0);
   \   00007E   7D401000     MOV.B   #0x10, R13
   \   000082   7C402200     MOV.B   #0x22, R12
   \   000086   B012....     CALL    #CC1101_Write_Reg
    202              CC1101_Write_Reg(cc1101_MCSM1,MCSM1);
   \   00008A   7D403000     MOV.B   #0x30, R13
   \   00008E   7C401700     MOV.B   #0x17, R12
   \   000092   B012....     CALL    #CC1101_Write_Reg
    203          	//MCSM0
    204          	CC1101_Write_Reg(cc1101_MCSM0,MCSM0);
   \   000096   7D401800     MOV.B   #0x18, R13
   \   00009A   7C401800     MOV.B   #0x18, R12
   \   00009E   B012....     CALL    #CC1101_Write_Reg
    205          	//FOCCFG
    206          	CC1101_Write_Reg(cc1101_FOCCFG,FOCCFG);
   \   0000A2   7D401D00     MOV.B   #0x1d, R13
   \   0000A6   7C401900     MOV.B   #0x19, R12
   \   0000AA   B012....     CALL    #CC1101_Write_Reg
    207          	//BSCFG
    208          	CC1101_Write_Reg(cc1101_BSCFG,BSCFG);
   \   0000AE   7D401C00     MOV.B   #0x1c, R13
   \   0000B2   7C401A00     MOV.B   #0x1a, R12
   \   0000B6   B012....     CALL    #CC1101_Write_Reg
    209          	//FSCAL
    210          	CC1101_Write_Reg(cc1101_FSCAL3,FSCAL3);
   \   0000BA   7D40EA00     MOV.B   #0xea, R13
   \   0000BE   7C402300     MOV.B   #0x23, R12
   \   0000C2   B012....     CALL    #CC1101_Write_Reg
    211          	CC1101_Write_Reg(cc1101_FSCAL2,FSCAL2);
   \   0000C6   7D402A00     MOV.B   #0x2a, R13
   \   0000CA   7C402400     MOV.B   #0x24, R12
   \   0000CE   B012....     CALL    #CC1101_Write_Reg
    212          	CC1101_Write_Reg(cc1101_FSCAL1,FSCAL1);
   \   0000D2   4D43         MOV.B   #0x0, R13
   \   0000D4   7C402500     MOV.B   #0x25, R12
   \   0000D8   B012....     CALL    #CC1101_Write_Reg
    213          	CC1101_Write_Reg(cc1101_FSCAL0,FSCAL0);
   \   0000DC   7D401F00     MOV.B   #0x1f, R13
   \   0000E0   7C402600     MOV.B   #0x26, R12
   \   0000E4   B012....     CALL    #CC1101_Write_Reg
    214          	///FSTEST TEST2 1 0
    215          	CC1101_Write_Reg(cc1101_FSTEST,FSTEST);
   \   0000E8   7D405900     MOV.B   #0x59, R13
   \   0000EC   7C402900     MOV.B   #0x29, R12
   \   0000F0   B012....     CALL    #CC1101_Write_Reg
    216          	CC1101_Write_Reg(cc1101_TEST2,TEST2);
   \   0000F4   7D408800     MOV.B   #0x88, R13
   \   0000F8   7C402C00     MOV.B   #0x2c, R12
   \   0000FC   B012....     CALL    #CC1101_Write_Reg
    217          	CC1101_Write_Reg(cc1101_TEST1,TEST1);
   \   000100   7D403100     MOV.B   #0x31, R13
   \   000104   7C402D00     MOV.B   #0x2d, R12
   \   000108   B012....     CALL    #CC1101_Write_Reg
    218          	CC1101_Write_Reg(cc1101_TEST0,TEST0);
   \   00010C   7D400900     MOV.B   #0x9, R13
   \   000110   7C402E00     MOV.B   #0x2e, R12
   \   000114   B012....     CALL    #CC1101_Write_Reg
    219          	//PKTCTRL 
    220          	CC1101_Write_Reg(cc1101_PKTCTRL1,PKTCTRL1);
   \   000118   7D400600     MOV.B   #0x6, R13
   \   00011C   7C400700     MOV.B   #0x7, R12
   \   000120   B012....     CALL    #CC1101_Write_Reg
    221          	CC1101_Write_Reg(cc1101_PKTCTRL0,PKTCTRL0);
   \   000124   7D400500     MOV.B   #0x5, R13
   \   000128   7C42         MOV.B   #0x8, R12
   \   00012A   B012....     CALL    #CC1101_Write_Reg
    222          	CC1101_Write_Reg(cc1101_PKTLEN,PKTLEN);
   \   00012E   7D43         MOV.B   #0xff, R13
   \   000130   7C400600     MOV.B   #0x6, R12
   \   000134   3040....     BR      #CC1101_Write_Reg
    223           }
    224          

   \                                 In  segment CODE, align 2
    225          void _delay_us(unsigned char x)
   \                     _delay_us:
   \                     ??_delay_us_0:
    226          {
    227          	unsigned long i;
    228          	
    229          	while(x --)
   \   000000   4E4C         MOV.B   R12, R14
   \   000002   4C4E         MOV.B   R14, R12
   \   000004   7C53         ADD.B   #0xff, R12
   \   000006   4E93         CMP.B   #0x0, R14
   \   000008   0C24         JEQ     ??_delay_us_2
    230          	{
    231          		for(i = 0;i < 2000;i++)
   \   00000A   0E43         MOV.W   #0x0, R14
   \   00000C   0F43         MOV.W   #0x0, R15
   \                     ??_delay_us_1:
   \   00000E   0F93         CMP.W   #0x0, R15
   \   000010   0428         JNC     ??_delay_us_3
   \   000012   F623         JNE     ??_delay_us_0
   \   000014   3E90D007     CMP.W   #0x7d0, R14
   \   000018   F32F         JC      ??_delay_us_0
    232          		{
    233          			asm("NOP");
   \                     ??_delay_us_3:
   \   00001A   0343         NOP
    234          		}
   \   00001C   1E53         ADD.W   #0x1, R14
   \   00001E   0F63         ADDC.W  #0x0, R15
   \   000020   F63F         JMP     ??_delay_us_1
    235          	}
    236          }
   \                     ??_delay_us_2:
   \   000022   3041         RET
    237          
    238          /* ============================================ *
    239           *                power up reset                *
    240           * ============================================ */

   \                                 In  segment CODE, align 2
    241           void CC1101_Power_Up(void) 
   \                     CC1101_Power_Up:
    242           {
    243          	//enable cc1101
    244          	Enable_CC1101;
   \   000000   F2C020002100 BIC.B   #0x20, &0x21
    245              _delay_us(10);
   \   000006   7C400A00     MOV.B   #0xa, R12
   \   00000A   B012....     CALL    #_delay_us
    246              //disable cc1101
    247          	Disable_CC1101;
   \   00000E   F2D020002100 BIS.B   #0x20, &0x21
    248          	//delay 40 us
    249          	_delay_us(40);
   \   000014   7C402800     MOV.B   #0x28, R12
   \   000018   B012....     CALL    #_delay_us
    250          	//enable cc1101
    251          	Enable_CC1101;
   \   00001C   F2C020002100 BIC.B   #0x20, &0x21
    252          	//wait cc1101 stabilize
    253          	while(CC1101_Check_So);
   \                     ??CC1101_Power_Up_0:
   \   000022   E2B32000     BIT.B   #0x2, &0x20
   \   000026   FD2F         JC      ??CC1101_Power_Up_0
    254          	//transmit cc1101 command
    255          	spi_readwrite(cc1101_SRES);
   \   000028   7C403000     MOV.B   #0x30, R12
   \   00002C   B012....     CALL    #spi_readwrite
    256          	//wait
    257          	while(CC1101_Check_So);
   \                     ??CC1101_Power_Up_1:
   \   000030   E2B32000     BIT.B   #0x2, &0x20
   \   000034   FD2F         JC      ??CC1101_Power_Up_1
    258          	//disable cc1101
    259          	Disable_CC1101;
   \   000036   F2D020002100 BIS.B   #0x20, &0x21
    260           }
   \   00003C   3041         RET
   \   00003E                REQUIRE P1OUT
   \   00003E                REQUIRE P1IN
    261             
    262          /* ============================================ *
    263           *                  rf set power                *
    264           * ============================================ */

   \                                 In  segment CODE, align 2
    265           void CC1101_Setting_Power(RF_Tx_Power power)
   \                     CC1101_Setting_Power:
    266           {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   4A4C         MOV.B   R12, R10
    267              unsigned char i,temp;
    268              //setting rf cc100 power address
    269          	temp = cc1101_PATABLE|WRITE_BURST;
   \   000006   7C407E00     MOV.B   #0x7e, R12
    270          	Enable_CC1101;
   \   00000A   F2C020002100 BIC.B   #0x20, &0x21
    271          	while(CC1101_Check_So);
   \                     ??CC1101_Setting_Power_0:
   \   000010   E2B32000     BIT.B   #0x2, &0x20
   \   000014   FD2F         JC      ??CC1101_Setting_Power_0
    272          	spi_readwrite(temp);
   \   000016   B012....     CALL    #spi_readwrite
    273          	//write data 8 times 
    274          	for(i=0;i<8;i++)
   \   00001A   4B43         MOV.B   #0x0, R11
   \   00001C   043C         JMP     ??CC1101_Setting_Power_2
    275          	{
    276          		spi_readwrite(power);
   \                     ??CC1101_Setting_Power_1:
   \   00001E   4C4A         MOV.B   R10, R12
   \   000020   B012....     CALL    #spi_readwrite
    277          	}
   \   000024   5B53         ADD.B   #0x1, R11
   \                     ??CC1101_Setting_Power_2:
   \   000026   7B92         CMP.B   #0x8, R11
   \   000028   FA2B         JNC     ??CC1101_Setting_Power_1
    278          	Disable_CC1101;
   \   00002A   F2D020002100 BIS.B   #0x20, &0x21
    279           }
   \   000030   3B41         POP.W   R11
   \   000032   3A41         POP.W   R10
   \   000034   3041         RET
   \   000036                REQUIRE P1OUT
   \   000036                REQUIRE P1IN
    280           
    281          /* ============================================ *
    282           *         rf Select transmit power             *
    283           * ============================================ */

   \                                 In  segment CODE, align 2
    284           void CC1101_Select_Transmit_Power_Level(Rf_Transmit_Level level)
   \                     CC1101_Select_Transmit_Power_Level:
    285           {
    286              switch(level)
   \   000000   8C11         SXT     R12
   \   000002   3C900A00     CMP.W   #0xa, R12
   \   000006   352C         JC      ??CC1101_Select_Transmit_Power_Level_0
   \   000008   0C5C         ADD.W   R12, R12
   \   00000A   104C....     BR      `?<Jumptable for CC1101_Select_Transmit_Power_L_0`(R12)
   \                     `?<Jumptable for CC1101_Select_Transmit_Power_L_0`:
   \   00000E   ....         DC16    ??CC1101_Select_Transmit_Power_Level_1
   \   000010   ....         DC16    ??CC1101_Select_Transmit_Power_Level_2
   \   000012   ....         DC16    ??CC1101_Select_Transmit_Power_Level_3
   \   000014   ....         DC16    ??CC1101_Select_Transmit_Power_Level_4
   \   000016   ....         DC16    ??CC1101_Select_Transmit_Power_Level_5
   \   000018   ....         DC16    ??CC1101_Select_Transmit_Power_Level_6
   \   00001A   ....         DC16    ??CC1101_Select_Transmit_Power_Level_7
   \   00001C   ....         DC16    ??CC1101_Select_Transmit_Power_Level_8
   \   00001E   ....         DC16    ??CC1101_Select_Transmit_Power_Level_9
   \   000020   ....         DC16    ??CC1101_Select_Transmit_Power_Level_10
    287              {
    288                  //max level
    289                  case Rf_Transmit_Level9 :
    290                  {
    291                      CC1101_Setting_Power(RF_TxPower_12dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_10:
   \   000022   7C40C000     MOV.B   #0xc0, R12
   \   000026   3040....     BR      #CC1101_Setting_Power
    292                  }break;
    293                  //level -8
    294                  case Rf_Transmit_Level8 :
    295                  { 
    296                      CC1101_Setting_Power(RF_TxPower_10dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_9:
   \   00002A   7C40C500     MOV.B   #0xc5, R12
   \   00002E   3040....     BR      #CC1101_Setting_Power
    297                  }break;
    298                  //level -7
    299                  case Rf_Transmit_Level7 : 
    300                  {
    301                      CC1101_Setting_Power(RF_TxPower_7dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_8:
   \   000032   7C40CD00     MOV.B   #0xcd, R12
   \   000036   3040....     BR      #CC1101_Setting_Power
    302                  }break;
    303                  //level -6
    304                  case Rf_Transmit_Level6 : 
    305                  {
    306                      CC1101_Setting_Power(RF_TxPower_5dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_7:
   \   00003A   7C408600     MOV.B   #0x86, R12
   \   00003E   3040....     BR      #CC1101_Setting_Power
    307                  }break;
    308                  //level -5
    309                  case Rf_Transmit_Level5 : 
    310                  {
    311                      CC1101_Setting_Power(RF_TxPower_0dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_6:
   \   000042   7C405000     MOV.B   #0x50, R12
   \   000046   3040....     BR      #CC1101_Setting_Power
    312                  }break;
    313                  //level -4
    314                  case Rf_Transmit_Level4 : 
    315                  {
    316                      CC1101_Setting_Power(RF_TxPower_N6dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_5:
   \   00004A   7C403700     MOV.B   #0x37, R12
   \   00004E   3040....     BR      #CC1101_Setting_Power
    317                  }break;
    318                  //level -3
    319                  case Rf_Transmit_Level3 :  
    320                  {
    321                      CC1101_Setting_Power(RF_TxPower_N10dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_4:
   \   000052   7C402600     MOV.B   #0x26, R12
   \   000056   3040....     BR      #CC1101_Setting_Power
    322                  }break;
    323                  //level -2
    324                  case Rf_Transmit_Level2 : 
    325                  {
    326                      CC1101_Setting_Power(RF_TxPower_N15dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_3:
   \   00005A   7C401D00     MOV.B   #0x1d, R12
   \   00005E   3040....     BR      #CC1101_Setting_Power
    327                  }break;
    328                  //level -1
    329                  case Rf_Transmit_Level1 : 
    330                  {
    331                      CC1101_Setting_Power(RF_TxPower_N20dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_2:
   \   000062   7C401700     MOV.B   #0x17, R12
   \   000066   3040....     BR      #CC1101_Setting_Power
    332                  }break;
    333                  //level -0
    334                  case Rf_Transmit_Level0 : 
    335                  {
    336                      CC1101_Setting_Power(RF_TxPower_N30dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_1:
   \   00006A   7C400300     MOV.B   #0x3, R12
   \   00006E   3040....     BR      #CC1101_Setting_Power
    337                  }break;
    338                  //default 0dbm 
    339                  default :
    340                  {
    341                      CC1101_Setting_Power(RF_TxPower_0dbm);
   \                     ??CC1101_Select_Transmit_Power_Level_0:
   \   000072   7C405000     MOV.B   #0x50, R12
   \   000076   3040....     BR      #CC1101_Setting_Power
    342                  }break;
    343              }
    344           }
    345          
    346          /* ============================================== *
    347           *               CC1101 set channel               *
    348           * ============================================== */

   \                                 In  segment CODE, align 2
    349           void CC1101_Setting_Channel(RF_Frequency_Channel channel)
   \                     CC1101_Setting_Channel:
    350           {
    351              //setting channel 
    352          	CC1101_Write_Reg(cc1101_CHANNR,channel);
   \   000000   4D4C         MOV.B   R12, R13
   \   000002   7C400A00     MOV.B   #0xa, R12
   \   000006   3040....     BR      #CC1101_Write_Reg
    353           }
    354           
    355          /* ============================================== *
    356           *           CC1101 set Synch Head word           *
    357           * ============================================== */

   \                                 In  segment CODE, align 2
    358           void CC1101_Setting_SynchHead(void)
   \                     CC1101_Setting_SynchHead:
    359           {
    360           	//SYNCH
    361          	CC1101_Write_Reg(cc1101_SYNC1,Hi_Uint8(Rf_Synch_Code));
   \   000000   7D40C500     MOV.B   #0xc5, R13
   \   000004   6C42         MOV.B   #0x4, R12
   \   000006   B012....     CALL    #CC1101_Write_Reg
    362          	CC1101_Write_Reg(cc1101_SYNC0,Lo_Uint8(Rf_Synch_Code));
   \   00000A   7D402600     MOV.B   #0x26, R13
   \   00000E   7C400500     MOV.B   #0x5, R12
   \   000012   3040....     BR      #CC1101_Write_Reg
    363           }
    364          
    365          /* ============================================== *
    366           *       CC1101 set carrier sense threshold       *
    367           * ============================================== */

   \                                 In  segment CODE, align 2
    368           void CC1101_CarrierSense_Threshold(RF_Threshold threshold)
   \                     CC1101_CarrierSense_Threshold:
    369           {
    370              switch(threshold)
   \   000000   4C83         SUB.B   #0x0, R12
   \   000002   0924         JEQ     ??CC1101_CarrierSense_Threshold_0
   \   000004   5C83         SUB.B   #0x1, R12
   \   000006   0E24         JEQ     ??CC1101_CarrierSense_Threshold_1
   \   000008   5C83         SUB.B   #0x1, R12
   \   00000A   1324         JEQ     ??CC1101_CarrierSense_Threshold_2
   \   00000C   5C83         SUB.B   #0x1, R12
   \   00000E   1824         JEQ     ??CC1101_CarrierSense_Threshold_3
   \   000010   5C83         SUB.B   #0x1, R12
   \   000012   1D24         JEQ     ??CC1101_CarrierSense_Threshold_4
   \   000014   233C         JMP     ??CC1101_CarrierSense_Threshold_5
    371              {
    372                  //-80dbm
    373                  case RF_Threshold_80dbm :
    374                  {
    375          	        CC1101_Write_Reg(cc1101_AGCCTRL2,0x0e);
   \                     ??CC1101_CarrierSense_Threshold_0:
   \   000016   7D400E00     MOV.B   #0xe, R13
   \   00001A   7C401B00     MOV.B   #0x1b, R12
   \   00001E   B012....     CALL    #CC1101_Write_Reg
    376                  }break;
   \   000022   223C         JMP     ??CC1101_CarrierSense_Threshold_6
    377                  //-78dbm
    378                  case RF_Threshold_78dbm :
    379                  {
    380          	        CC1101_Write_Reg(cc1101_AGCCTRL2,0x15);
   \                     ??CC1101_CarrierSense_Threshold_1:
   \   000024   7D401500     MOV.B   #0x15, R13
   \   000028   7C401B00     MOV.B   #0x1b, R12
   \   00002C   B012....     CALL    #CC1101_Write_Reg
    381                  }break;
   \   000030   1B3C         JMP     ??CC1101_CarrierSense_Threshold_6
    382                  //-75dbm 
    383                  case RF_Threshold_75dbm :
    384                  {
    385          	        CC1101_Write_Reg(cc1101_AGCCTRL2,0x17);
   \                     ??CC1101_CarrierSense_Threshold_2:
   \   000032   7D401700     MOV.B   #0x17, R13
   \   000036   7C401B00     MOV.B   #0x1b, R12
   \   00003A   B012....     CALL    #CC1101_Write_Reg
    386                  }break;
   \   00003E   143C         JMP     ??CC1101_CarrierSense_Threshold_6
    387                  //-72dbm 
    388                  case RF_Threshold_72dbm :
    389                  {
    390          	        CC1101_Write_Reg(cc1101_AGCCTRL2,0x1f);
   \                     ??CC1101_CarrierSense_Threshold_3:
   \   000040   7D401F00     MOV.B   #0x1f, R13
   \   000044   7C401B00     MOV.B   #0x1b, R12
   \   000048   B012....     CALL    #CC1101_Write_Reg
    391                  }break;
   \   00004C   0D3C         JMP     ??CC1101_CarrierSense_Threshold_6
    392                  //-68dbm 
    393                  case RF_Threshold_68dbm :
    394                  {
    395          	        CC1101_Write_Reg(cc1101_AGCCTRL2,0x2f);
   \                     ??CC1101_CarrierSense_Threshold_4:
   \   00004E   7D402F00     MOV.B   #0x2f, R13
   \   000052   7C401B00     MOV.B   #0x1b, R12
   \   000056   B012....     CALL    #CC1101_Write_Reg
    396                  }break;
   \   00005A   063C         JMP     ??CC1101_CarrierSense_Threshold_6
    397                  //otherwise way -72dbm 
    398                  default :
    399                  {
    400          	        CC1101_Write_Reg(cc1101_AGCCTRL2,0x1f);
   \                     ??CC1101_CarrierSense_Threshold_5:
   \   00005C   7D401F00     MOV.B   #0x1f, R13
   \   000060   7C401B00     MOV.B   #0x1b, R12
   \   000064   B012....     CALL    #CC1101_Write_Reg
    401                  }break;
    402              }
    403              CC1101_Write_Reg(cc1101_AGCCTRL1,AGCCTRL1);
   \                     ??CC1101_CarrierSense_Threshold_6:
   \   000068   7D404100     MOV.B   #0x41, R13
   \   00006C   7C401C00     MOV.B   #0x1c, R12
   \   000070   B012....     CALL    #CC1101_Write_Reg
    404              CC1101_Write_Reg(cc1101_AGCCTRL0,AGCCTRL0);
   \   000074   7D409100     MOV.B   #0x91, R13
   \   000078   7C401D00     MOV.B   #0x1d, R12
   \   00007C   3040....     BR      #CC1101_Write_Reg
    405           }
    406          
    407          /* ============================================== *
    408           *                 CC1101 set Gpio2               *
    409           * ============================================== */

   \                                 In  segment CODE, align 2
    410           void CC1101_Config_Gpio2(RF_Gpio gpio)
   \                     CC1101_Config_Gpio2:
    411           {
    412          	//IOCFG
    413              CC1101_Write_Reg(cc1101_IOCFG2,gpio);
   \   000000   4D4C         MOV.B   R12, R13
   \   000002   4C43         MOV.B   #0x0, R12
   \   000004   3040....     BR      #CC1101_Write_Reg
    414           }
    415          
    416          /* ============================================== *
    417           *                 CC1101 set Gpio0               *
    418           * ============================================== */

   \                                 In  segment CODE, align 2
    419           void CC1101_Config_Gpio0(RF_Gpio gpio)
   \                     CC1101_Config_Gpio0:
    420           {
    421          	//IOCFG
    422              CC1101_Write_Reg(cc1101_IOCFG0,gpio);
   \   000000   4D4C         MOV.B   R12, R13
   \   000002   6C43         MOV.B   #0x2, R12
   \   000004   3040....     BR      #CC1101_Write_Reg
    423           }
    424          
    425          /* ============================================== *
    426           *            setting cc1101 address              *
    427           * ============================================== */

   \                                 In  segment CODE, align 2
    428           void CC1101_Setting_Address(unsigned char Addr)
   \                     CC1101_Setting_Address:
    429           {
    430              CC1101_Write_Reg(cc1101_ADDR,Addr);
   \   000000   4D4C         MOV.B   R12, R13
   \   000002   7C400900     MOV.B   #0x9, R12
   \   000006   3040....     BR      #CC1101_Write_Reg
    431           }
    432          
    433          /* ============================================== *
    434           *         CC1101 set Frequency section           *
    435           * ============================================== */

   \                                 In  segment CODE, align 2
    436           void CC1101_Setting_FreSection(RF_Frequency_Section section)
   \                     CC1101_Setting_FreSection:
    437           {
    438               switch(section)
   \   000000   4C83         SUB.B   #0x0, R12
   \   000002   0724         JEQ     ??CC1101_Setting_FreSection_0
   \   000004   5C83         SUB.B   #0x1, R12
   \   000006   1724         JEQ     ??CC1101_Setting_FreSection_1
   \   000008   5C83         SUB.B   #0x1, R12
   \   00000A   2724         JEQ     ??CC1101_Setting_FreSection_2
   \   00000C   5C83         SUB.B   #0x1, R12
   \   00000E   3724         JEQ     ??CC1101_Setting_FreSection_3
   \   000010   483C         JMP     ??CC1101_Setting_FreSection_4
    439               {
    440                   //ism 315MHz
    441                   case RF_ISM_315MHz :
    442                   {
    443          	        CC1101_Write_Reg(cc1101_FREQ2,0x0c);
   \                     ??CC1101_Setting_FreSection_0:
   \   000012   7D400C00     MOV.B   #0xc, R13
   \   000016   7C400D00     MOV.B   #0xd, R12
   \   00001A   B012....     CALL    #CC1101_Write_Reg
    444           	        CC1101_Write_Reg(cc1101_FREQ1,0x1d);
   \   00001E   7D401D00     MOV.B   #0x1d, R13
   \   000022   7C400E00     MOV.B   #0xe, R12
   \   000026   B012....     CALL    #CC1101_Write_Reg
    445          	        CC1101_Write_Reg(cc1101_FREQ0,0x89);
   \   00002A   7D408900     MOV.B   #0x89, R13
   \   00002E   7C400F00     MOV.B   #0xf, R12
   \   000032   3040....     BR      #CC1101_Write_Reg
    446                   }break;
    447                   //ISM 433MHz 
    448                   case RF_ISM_433MHz :
    449                   {
    450          	        CC1101_Write_Reg(cc1101_FREQ2,0x10);
   \                     ??CC1101_Setting_FreSection_1:
   \   000036   7D401000     MOV.B   #0x10, R13
   \   00003A   7C400D00     MOV.B   #0xd, R12
   \   00003E   B012....     CALL    #CC1101_Write_Reg
    451           	        CC1101_Write_Reg(cc1101_FREQ1,0xa7);
   \   000042   7D40A700     MOV.B   #0xa7, R13
   \   000046   7C400E00     MOV.B   #0xe, R12
   \   00004A   B012....     CALL    #CC1101_Write_Reg
    452          	        CC1101_Write_Reg(cc1101_FREQ0,0x62); 
   \   00004E   7D406200     MOV.B   #0x62, R13
   \   000052   7C400F00     MOV.B   #0xf, R12
   \   000056   3040....     BR      #CC1101_Write_Reg
    453                   }break;
    454                   //ISM 868MHz
    455                   case RF_ISM_868MHz :
    456          	     {
    457                      //CC1101_Write_Reg(cc1101_FREQ2,0x21);
    458           	        //CC1101_Write_Reg(cc1101_FREQ1,0x62);
    459          	        //CC1101_Write_Reg(cc1101_FREQ0,0x76);
    460                      CC1101_Write_Reg(cc1101_FREQ2,0x21);
   \                     ??CC1101_Setting_FreSection_2:
   \   00005A   7D402100     MOV.B   #0x21, R13
   \   00005E   7C400D00     MOV.B   #0xd, R12
   \   000062   B012....     CALL    #CC1101_Write_Reg
    461           	        CC1101_Write_Reg(cc1101_FREQ1,0x13);
   \   000066   7D401300     MOV.B   #0x13, R13
   \   00006A   7C400E00     MOV.B   #0xe, R12
   \   00006E   B012....     CALL    #CC1101_Write_Reg
    462          	        CC1101_Write_Reg(cc1101_FREQ0,0xb1);
   \   000072   7D40B100     MOV.B   #0xb1, R13
   \   000076   7C400F00     MOV.B   #0xf, R12
   \   00007A   3040....     BR      #CC1101_Write_Reg
    463                   }break;
    464                   //ISM 915MHz
    465                   case RF_ISM_915MHz :
    466                   {
    467          	        CC1101_Write_Reg(cc1101_FREQ2,0x23);
   \                     ??CC1101_Setting_FreSection_3:
   \   00007E   7D402300     MOV.B   #0x23, R13
   \   000082   7C400D00     MOV.B   #0xd, R12
   \   000086   B012....     CALL    #CC1101_Write_Reg
    468           	        CC1101_Write_Reg(cc1101_FREQ1,0x31);
   \   00008A   7D403100     MOV.B   #0x31, R13
   \   00008E   7C400E00     MOV.B   #0xe, R12
   \   000092   B012....     CALL    #CC1101_Write_Reg
    469          	        CC1101_Write_Reg(cc1101_FREQ0,0x3b);
   \   000096   7D403B00     MOV.B   #0x3b, R13
   \   00009A   7C400F00     MOV.B   #0xf, R12
   \   00009E   3040....     BR      #CC1101_Write_Reg
    470                   }break;
    471                   //otherwise is ISM 433MHz
    472                   default :
    473                   {
    474          	        CC1101_Write_Reg(cc1101_FREQ2,0x10);
   \                     ??CC1101_Setting_FreSection_4:
   \   0000A2   7D401000     MOV.B   #0x10, R13
   \   0000A6   7C400D00     MOV.B   #0xd, R12
   \   0000AA   B012....     CALL    #CC1101_Write_Reg
    475           	        CC1101_Write_Reg(cc1101_FREQ1,0xa7);
   \   0000AE   7D40A700     MOV.B   #0xa7, R13
   \   0000B2   7C400E00     MOV.B   #0xe, R12
   \   0000B6   B012....     CALL    #CC1101_Write_Reg
    476          	        CC1101_Write_Reg(cc1101_FREQ0,0x62);
   \   0000BA   7D406200     MOV.B   #0x62, R13
   \   0000BE   7C400F00     MOV.B   #0xf, R12
   \   0000C2   3040....     BR      #CC1101_Write_Reg
    477                   }break;
    478               }
    479           }
    480          
    481          /* ============================================== *
    482           *               CC1101 entry x mode              *
    483           * ============================================== */

   \                                 In  segment CODE, align 2
    484           void CC1101_Entry_XMode(RF_Mode Mode)
   \                     CC1101_Entry_XMode:
    485           {
   \   000000   0A12         PUSH.W  R10
   \   000002   4A4C         MOV.B   R12, R10
    486              //idle mode 
    487              CC1101_Strobe(cc1101_SIDLE);
   \   000004   7C403600     MOV.B   #0x36, R12
   \   000008   B012....     CALL    #CC1101_Strobe
    488              switch(Mode)
   \   00000C   8A11         SXT     R10
   \   00000E   3A900900     CMP.W   #0x9, R10
   \   000012   372C         JC      ??CC1101_Entry_XMode_0
   \   000014   0A5A         ADD.W   R10, R10
   \   000016   104A....     BR      `?<Jumptable for CC1101_Entry_XMode>_0`(R10)
   \                     `?<Jumptable for CC1101_Entry_XMode>_0`:
   \   00001A   ....         DC16    ??CC1101_Entry_XMode_1
   \   00001C   ....         DC16    ??CC1101_Entry_XMode_2
   \   00001E   ....         DC16    ??CC1101_Entry_XMode_0
   \   000020   ....         DC16    ??CC1101_Entry_XMode_3
   \   000022   ....         DC16    ??CC1101_Entry_XMode_4
   \   000024   ....         DC16    ??CC1101_Entry_XMode_5
   \   000026   ....         DC16    ??CC1101_Entry_XMode_6
   \   000028   ....         DC16    ??CC1101_Entry_XMode_7
   \   00002A   ....         DC16    ??CC1101_Entry_XMode_8
    489              {
    490                  //rf rx mode
    491                  case Rf_Rx_Mode : 
    492                  {
    493                      //CC1100 回到接收模式 
    494                      CC1101_Strobe(cc1101_SRX);
   \                     ??CC1101_Entry_XMode_1:
   \   00002C   7C403400     MOV.B   #0x34, R12
   \   000030   B012....     CALL    #CC1101_Strobe
    495                  }break;
   \   000034   263C         JMP     ??CC1101_Entry_XMode_0
    496                  //rf tx mode
    497                  case Rf_Tx_Mode :  
    498                  {
    499                      //进入发送模式发送数据
    500          	        CC1101_Strobe(cc1101_STX);
   \                     ??CC1101_Entry_XMode_2:
   \   000036   7C403500     MOV.B   #0x35, R12
   \   00003A   B012....     CALL    #CC1101_Strobe
    501                  }break;
   \   00003E   213C         JMP     ??CC1101_Entry_XMode_0
    502                  //rf idle mode
    503                  case Rf_Idle_Mode :
    504                  {
    505                      
    506                  }break;
    507                  //rf WOR mode
    508                  case Rf_Wor_Mode :
    509                  {
    510                      CC1101_Strobe(cc1101_SWOR);
   \                     ??CC1101_Entry_XMode_3:
   \   000040   7C403800     MOV.B   #0x38, R12
   \   000044   B012....     CALL    #CC1101_Strobe
    511                  }break;
   \   000048   1C3C         JMP     ??CC1101_Entry_XMode_0
    512                  //rf power down mode
    513                  case Rf_Pwd_Mode :
    514                  {
    515                      CC1101_Strobe(cc1101_SPWD);
   \                     ??CC1101_Entry_XMode_4:
   \   00004A   7C403900     MOV.B   #0x39, R12
   \   00004E   B012....     CALL    #CC1101_Strobe
    516                  }break;
   \   000052   173C         JMP     ??CC1101_Entry_XMode_0
    517                  //rf frequency scal 
    518                  case Rf_Frq_Scal :
    519                  {
    520                      //开启和校准频率合成器....
    521          	        CC1101_Strobe(cc1101_SCAL); 
   \                     ??CC1101_Entry_XMode_5:
   \   000054   7C403300     MOV.B   #0x33, R12
   \   000058   B012....     CALL    #CC1101_Strobe
    522                  }break;
   \   00005C   123C         JMP     ??CC1101_Entry_XMode_0
    523                  //flush rx fifo
    524                  case Rf_Flush_RxFifo :
    525                  {
    526                      CC1101_Strobe(cc1101_SFRX); 
   \                     ??CC1101_Entry_XMode_6:
   \   00005E   7C403A00     MOV.B   #0x3a, R12
   \   000062   B012....     CALL    #CC1101_Strobe
    527                  }break;
   \   000066   0D3C         JMP     ??CC1101_Entry_XMode_0
    528                  //flush tx fifo
    529                  case Rf_Flush_TxFfio :
    530                  {
    531                      CC1101_Strobe(cc1101_SFTX);
   \                     ??CC1101_Entry_XMode_7:
   \   000068   7C403B00     MOV.B   #0x3b, R12
   \   00006C   B012....     CALL    #CC1101_Strobe
    532                  }break;
   \   000070   083C         JMP     ??CC1101_Entry_XMode_0
    533                  //entry rx mode and flush rx fifo
    534                  case Rf_Rx_Flush_RxFifo :
    535                  {
    536                      //清空接收缓冲区
    537                      CC1101_Strobe(cc1101_SFRX);
   \                     ??CC1101_Entry_XMode_8:
   \   000072   7C403A00     MOV.B   #0x3a, R12
   \   000076   B012....     CALL    #CC1101_Strobe
    538                      //CC1100 回到接收模式
    539                      CC1101_Strobe(cc1101_SRX);
   \   00007A   7C403400     MOV.B   #0x34, R12
   \   00007E   B012....     CALL    #CC1101_Strobe
    540                  }break;
    541                  //otherwise none
    542                  default :
    543                   break;
    544              }                 
    545           }
   \                     ??CC1101_Entry_XMode_0:
   \   000082   3A41         POP.W   R10
   \   000084   3041         RET
    546           
    547           /* ============================================== *
    548            *            CC1101 Initialization               *
    549            * ============================================== */

   \                                 In  segment CODE, align 2
    550           void CC1101_Config_Pins(void)
   \                     CC1101_Config_Pins:
    551           {
    552              //cs
    553          	CS_OUTPUT;           //output
   \   000000   F2D020002200 BIS.B   #0x20, &0x22
    554          	Disable_CC1101;      //high
   \   000006   F2D020002100 BIS.B   #0x20, &0x21
    555          	//si
    556          	SI_OUTPUT;           //output
   \   00000C   E2D22200     BIS.B   #0x4, &0x22
    557          	CC1101_Si_Low;       //low
   \   000010   E2C22100     BIC.B   #0x4, &0x21
    558          	//so
    559          	SO_INPUT;            //input
   \   000014   E2C32200     BIC.B   #0x2, &0x22
    560          	CC1101_So_High;      //high
   \   000018   E2D32100     BIS.B   #0x2, &0x21
    561          	//sclk
    562          	SCLK_OUTPUT;         //output
   \   00001C   F2D010002200 BIS.B   #0x10, &0x22
    563          	CC1101_Sclk_High;     //low
   \   000022   F2D010002100 BIS.B   #0x10, &0x21
    564          	//gdo0
    565          	GDO0_INPUT;          //output
   \   000028   D2C32A00     BIC.B   #0x1, &0x2a
    566          //	CC1101_Gdo0_High;    //low
    567          
    568          	//gdo2
    569          	GDO2_INPUT;          //input
   \   00002C   E2C32A00     BIC.B   #0x2, &0x2a
    570          //	CC1101_Gdo2_High;    //low
    571          
    572           }
   \   000030   3041         RET
   \   000032                REQUIRE P1DIR
   \   000032                REQUIRE P1OUT
   \   000032                REQUIRE P2DIR
    573          
    574          /* ============================================== *
    575           *          CC1101 Interrupt  Config              *
    576           * ============================================== */

   \                                 In  segment CODE, align 2
    577           void CC1101_Interrupt_Config(unsigned char priority)
   \                     CC1101_Interrupt_Config:
    578           {
    579              //config interupt pin 
    580          //    RPINR0bits.INT1R = Rf_Interrupt_Pin;
    581          	P2IE  |= BIT0;
   \   000000   D2D32D00     BIS.B   #0x1, &0x2d
    582          	P2IES |= BIT0;					// 选择上升/下降沿
   \   000004   D2D32C00     BIS.B   #0x1, &0x2c
    583          //	P2REN |= BIT0;					// 上拉
    584              //clean interrupt isr flag
    585              Clean_Interrupt_ISR_Flag;
   \   000008   D2C32B00     BIC.B   #0x1, &0x2b
    586              //config interupt level
    587          //    IPC5bits.INT1IP   = priority;
    588              //Up level interrupt 
    589              Enable_DownLevel_Interrupt;
    590              //enable interrupt 
    591              Enable_Interrupt;
   \   00000C   D2D32D00     BIS.B   #0x1, &0x2d
    592           }
   \   000010   3041         RET
   \   000012                REQUIRE P2IE
   \   000012                REQUIRE P2IES
   \   000012                REQUIRE P2IFG
    593           
    594          /* ============================================== *
    595           *            rf mac rx buffer initial            *
    596           * ============================================== */

   \                                 In  segment CODE, align 2
    597           void CC1101_RxBuffer_Initial(void)
   \                     CC1101_RxBuffer_Initial:
    598           {
    599              ptrRxBufWrite = &RxBuf[0];
   \   000000   B240........ MOV.W   #RxBuf, &ptrRxBufWrite
    600           	ptrRxBufRead  = &RxBuf[0];
   \   000006   B240........ MOV.W   #RxBuf, &ptrRxBufRead
    601           }
   \   00000C   3041         RET
    602           
    603          /* ============================================== *
    604           *          CC1101 enter into sleep mode          *
    605           * ============================================== */

   \                                 In  segment CODE, align 2
    606           void CC1101_EnterIntoSleepMode(void)
   \                     CC1101_EnterIntoSleepMode:
    607           {
    608              //cc1101 power down 
    609              CC1101_Entry_XMode(Rf_Pwd_Mode);
   \   000000   6C42         MOV.B   #0x4, R12
   \   000002   3040....     BR      #CC1101_Entry_XMode
    610           }
    611          
    612          /* ============================================== *
    613           *          CC1101 wake up to idle mode           *
    614           * ============================================== */

   \                                 In  segment CODE, align 2
    615           void CC1101_WakeUpToIdleMode(void)
   \                     CC1101_WakeUpToIdleMode:
    616           {
    617              //wake up cc1101
    618              Enable_CC1101;
   \   000000   F2C020002100 BIC.B   #0x20, &0x21
    619              //delay 100us 
    620              _delay_us(100);
   \   000006   7C406400     MOV.B   #0x64, R12
   \   00000A   B012....     CALL    #_delay_us
    621          	Disable_CC1101;
   \   00000E   F2D020002100 BIS.B   #0x20, &0x21
    622              //rf frequency scal 
    623              CC1101_Entry_XMode(Rf_Frq_Scal);
   \   000014   7C400500     MOV.B   #0x5, R12
   \   000018   3040....     BR      #CC1101_Entry_XMode
   \   00001C                REQUIRE P1OUT
    624           }
    625          
    626           /* ============================================== *
    627            *            CC1101 Initialization               *
    628            * ============================================== */

   \                                 In  segment CODE, align 2
    629           void CC1101_Initialization(void)
   \                     CC1101_Initialization:
    630           {
    631              //Confing CC1101 Pins
    632              CC1101_Config_Pins();
   \   000000   B012....     CALL    #CC1101_Config_Pins
    633              //spi initial
    634          //    APISpiModuleInitial();
    635              //disable rf interrupt
    636              Disable_Interrupt;
   \   000004   D2C32D00     BIC.B   #0x1, &0x2d
    637          	//power un and reset
    638          	CC1101_Power_Up();
   \   000008   B012....     CALL    #CC1101_Power_Up
    639          	//cc1100 setting config register
    640          	CC1101_Rf_Write_Settings();
   \   00000C   B012....     CALL    #CC1101_Rf_Write_Settings
    641              //setting cc1101 synch head word 
    642              CC1101_Setting_SynchHead();
   \   000010   B012....     CALL    #CC1101_Setting_SynchHead
    643              //config gpio function
    644              CC1101_Config_Gpio2(IOCFG2);
   \   000014   7C400E00     MOV.B   #0xe, R12
   \   000018   B012....     CALL    #CC1101_Config_Gpio2
    645              CC1101_Config_Gpio0(IOCFG0);
   \   00001C   7C400600     MOV.B   #0x6, R12
   \   000020   B012....     CALL    #CC1101_Config_Gpio0
    646          	//check CC1101 initial whether success.....
    647          	if(CC1101_Read_Reg(cc1101_IOCFG2) != IOCFG2)
   \   000024   4C43         MOV.B   #0x0, R12
   \   000026   B012....     CALL    #CC1101_Read_Reg
   \   00002A   7C900E00     CMP.B   #0xe, R12
   \   00002E   0124         JEQ     ??CC1101_Initialization_1
    648          	{
    649          	    for(;;)
   \                     ??CC1101_Initialization_0:
   \   000030   FF3F         JMP     ??CC1101_Initialization_0
    650          		{
    651          		    #ifdef CC1101_BreakDown_Status
    652          			    //LED to TGL
    653          //			    CC1101_BreakDown_Status;
    654          //				_delay_ms(250);
    655          			#endif
    656          		}
    657          	}
    658          	
    659          	CC1101_Select_Transmit_Power_Level(Rf_Transmit_Level5);
   \                     ??CC1101_Initialization_1:
   \   000032   7C400500     MOV.B   #0x5, R12
   \   000036   B012....     CALL    #CC1101_Select_Transmit_Power_Level
    660          	CC1101_Setting_Channel(RF_Frequency_Channel10);
   \   00003A   7C400A00     MOV.B   #0xa, R12
   \   00003E   B012....     CALL    #CC1101_Setting_Channel
    661          	CC1101_CarrierSense_Threshold(RF_Threshold_72dbm);
   \   000042   7C400300     MOV.B   #0x3, R12
   \   000046   B012....     CALL    #CC1101_CarrierSense_Threshold
    662          	CC1101_Setting_Address(0x01);
   \   00004A   5C43         MOV.B   #0x1, R12
   \   00004C   B012....     CALL    #CC1101_Setting_Address
    663          	CC1101_Setting_FreSection(RF_ISM_868MHz);
   \   000050   6C43         MOV.B   #0x2, R12
   \   000052   B012....     CALL    #CC1101_Setting_FreSection
    664          //	CC1101_Entry_XMode(Rf_Rx_Mode);
    665          	
    666          	
    667              //wish cc1101 rx fifo ...
    668              CC1101_Entry_XMode(Rf_Flush_RxFifo);
   \   000056   7C400600     MOV.B   #0x6, R12
   \   00005A   B012....     CALL    #CC1101_Entry_XMode
    669              //wish cc1101 tx fifo ...
    670              CC1101_Entry_XMode(Rf_Flush_TxFfio);
   \   00005E   7C400700     MOV.B   #0x7, R12
   \   000062   B012....     CALL    #CC1101_Entry_XMode
    671          	
    672              //config ... 
    673              CC1101_Interrupt_Config(Rf_Level_Priority);
   \   000066   7C400700     MOV.B   #0x7, R12
   \   00006A   B012....     CALL    #CC1101_Interrupt_Config
    674          	
    675          	CC1101_Entry_XMode(Rf_Rx_Mode);
   \   00006E   4C43         MOV.B   #0x0, R12
   \   000070   3040....     BR      #CC1101_Entry_XMode
   \   000074                REQUIRE P2IE
    676           }
    677           
    678          /* ============================================ *
    679           *              rf cc1101 write FIFO            *
    680           * ============================================ */

   \                                 In  segment CODE, align 2
    681           void CC1101_Write_Fifo(unsigned char *txptr,unsigned char size)
   \                     CC1101_Write_Fifo:
    682           {
   \   000000   0A12         PUSH.W  R10
   \   000002   0B12         PUSH.W  R11
   \   000004   0B4C         MOV.W   R12, R11
   \   000006   4A4D         MOV.B   R13, R10
    683          //	unsigned char Rex;
    684              StoreAndDisRfInterrupt(Rex);
   \   000008   D2C32D00     BIC.B   #0x1, &0x2d
    685              //length
    686          	CC1101_Write_Reg(cc1101_TXFIFO, size);
   \   00000C   4D4A         MOV.B   R10, R13
   \   00000E   7C403F00     MOV.B   #0x3f, R12
   \   000012   B012....     CALL    #CC1101_Write_Reg
    687              //write data buffer 
    688          	CC1101_Write_Burst_Reg(cc1101_TXFIFO,txptr,size);
   \   000016   4E4A         MOV.B   R10, R14
   \   000018   0D4B         MOV.W   R11, R13
   \   00001A   7C403F00     MOV.B   #0x3f, R12
   \   00001E   B012....     CALL    #CC1101_Write_Burst_Reg
    689              RestoreRfInterrupt(Rex);
   \   000022   D2D32D00     BIS.B   #0x1, &0x2d
    690           }
   \   000026   3B41         POP.W   R11
   \   000028   3A41         POP.W   R10
   \   00002A   3041         RET
   \   00002C                REQUIRE P2IE
    691           
    692          /* ============================================ *
    693           *              rf cc1101 send packet           *
    694           * ============================================ */

   \                                 In  segment CODE, align 2
    695           void CC1101_Send_Packet(void)
   \                     CC1101_Send_Packet:
    696           {	
    697          //    unsigned char Rex;
    698              //disable rf interrupt
    699              StoreAndDisRfInterrupt(Rex);
   \   000000   D2C32D00     BIC.B   #0x1, &0x2d
    700              //rx mode after tx
    701              CC1101_Entry_XMode(Rf_Tx_Mode);
   \   000004   5C43         MOV.B   #0x1, R12
   \   000006   B012....     CALL    #CC1101_Entry_XMode
   \   00000A   013C         JMP     ??CC1101_Send_Packet_2
    702          	// Wait for GDO0 to be set -> sync transmitted  
    703          	while(!Check_Rf_Level)
    704              {
    705          	   asm("nop");
   \                     ??CC1101_Send_Packet_0:
   \   00000C   0343         nop
    706              }
   \                     ??CC1101_Send_Packet_2:
   \   00000E   D2B32800     BIT.B   #0x1, &0x28
   \   000012   FC2B         JNC     ??CC1101_Send_Packet_0
    707          	// Wait for GDO0 to be cleared -> end of packet  
    708          	while(Check_Rf_Level)
   \                     ??CC1101_Send_Packet_1:
   \   000014   D2B32800     BIT.B   #0x1, &0x28
   \   000018   0228         JNC     ??CC1101_Send_Packet_3
    709              {
    710          	   asm("nop");
   \   00001A   0343         nop
   \   00001C   FB3F         JMP     ??CC1101_Send_Packet_1
    711              }
    712          //	_delay_us(100);
    713              //wish cc1101 tx fifo
    714              CC1101_Entry_XMode(Rf_Flush_TxFfio);
   \                     ??CC1101_Send_Packet_3:
   \   00001E   7C400700     MOV.B   #0x7, R12
   \   000022   B012....     CALL    #CC1101_Entry_XMode
    715              //rx mode after tx 
    716              CC1101_Entry_XMode(Rf_Rx_Mode);
   \   000026   4C43         MOV.B   #0x0, R12
   \   000028   B012....     CALL    #CC1101_Entry_XMode
    717              //enable rf rx interrupt
    718          	Clean_Interrupt_ISR_Flag;
   \   00002C   D2C32B00     BIC.B   #0x1, &0x2b
    719              RestoreRfInterrupt(Rex);
   \   000030   D2D32D00     BIS.B   #0x1, &0x2d
    720           }
   \   000034   3041         RET
   \   000036                REQUIRE P2IE
   \   000036                REQUIRE P2IN
   \   000036                REQUIRE P2IFG
    721           
    722          /* ======================================= * 
    723           *     check cc1101 rx buffer is free?     * 
    724           * ======================================= */

   \                                 In  segment CODE, align 2
    725           void CC1101_Read_Packet(unsigned char length)
   \                     CC1101_Read_Packet:
    726           {
   \   000000   4E4C         MOV.B   R12, R14
    727              unsigned int remain;
    728              //check rx buffer wheterh free .....
    729              remain = CC1101_Check_RxBuffer_Free();
   \   000002   B012....     CALL    #CC1101_Check_RxBuffer_Free
    730              //add status bytes
    731              length += RfFcsBytes;
   \   000006   6E53         ADD.B   #0x2, R14
    732              //check rx buffer space wheterh enough...
    733              if(remain < length)
   \   000008   4E4E         MOV.B   R14, R14
   \   00000A   0C9E         CMP.W   R14, R12
   \   00000C   1028         JNC     ??CC1101_Read_Packet_1
    734          	{
    735                   return;
    736              }
    737              //write length of data packet 
    738              *ptrRxBufWrite++ =  length;
   \   00000E   1F42....     MOV.W   &ptrRxBufWrite, R15
   \   000012   CF4E0000     MOV.B   R14, 0(R15)
   \   000016   9253....     ADD.W   #0x1, &ptrRxBufWrite
    739              if(ptrRxBufWrite == ptrRxBufOver)
   \   00001A   9292........ CMP.W   &ptrRxBufOver, &ptrRxBufWrite
   \   000020   0320         JNE     ??CC1101_Read_Packet_2
    740              {
    741                  ptrRxBufWrite = &RxBuf[0];
   \   000022   B240........ MOV.W   #RxBuf, &ptrRxBufWrite
    742              }
    743              //read cc1101 FIFO to RXbuffer 
    744              CC1101_Read_Burst_Reg(length);
   \                     ??CC1101_Read_Packet_2:
   \   000028   4C4E         MOV.B   R14, R12
   \   00002A   B012....     CALL    #CC1101_Read_Burst_Reg
    745           }
   \                     ??CC1101_Read_Packet_1:
   \   00002E   3041         RET
    746           
    747          /* ============================================ *
    748           *             rf cc1100 receive packet         *
    749           * status[0] = RSSI-->6:2, status[1] = LQI      *
    750           * ============================================ */

   \                                 In  segment CODE, align 2
    751           void CC1101_Receive_Packet(void)
   \                     CC1101_Receive_Packet:
    752           {
    753          	//check CRC
    754              if(CC1101_Read_Status(cc1101_LQI) & cc1101_CRC_OK)
   \   000000   7C403300     MOV.B   #0x33, R12
   \   000004   B012....     CALL    #CC1101_Read_Status
   \   000008   4C93         CMP.B   #0x0, R12
   \   00000A   0B34         JGE     ??CC1101_Receive_Packet_0
    755          	{
    756          	    unsigned char length;
    757                  //get length of data packet
    758          		length=CC1101_Read_Reg(cc1101_RXFIFO);
   \   00000C   7C403F00     MOV.B   #0x3f, R12
   \   000010   B012....     CALL    #CC1101_Read_Reg
    759          		
    760          		if((length > 0)&&(length <= MAX_RX_DATA_LEN))
   \   000014   4E4C         MOV.B   R12, R14
   \   000016   5E83         SUB.B   #0x1, R14
   \   000018   7E903E00     CMP.B   #0x3e, R14
   \   00001C   022C         JC      ??CC1101_Receive_Packet_0
    761          		{	
    762          			//get data packet
    763          		    CC1101_Read_Packet(length);
   \   00001E   B012....     CALL    #CC1101_Read_Packet
    764          	    }
    765          	}
    766              //CC1100 回到接收模式
    767              CC1101_Entry_XMode(Rf_Rx_Flush_RxFifo); 	
   \                     ??CC1101_Receive_Packet_0:
   \   000022   7C42         MOV.B   #0x8, R12
   \   000024   3040....     BR      #CC1101_Entry_XMode
    768           }
    769          
    770          /* ======================================= *
    771           *     check cc1101 rx buffer is free?     *
    772           * ======================================= */

   \                                 In  segment CODE, align 2
    773           unsigned int CC1101_Check_RxBuffer_Free(void)
   \                     CC1101_Check_RxBuffer_Free:
    774           {  
    775          //    unsigned char  Rex;
    776              unsigned int   remain;
    777              //disable rf interrupt
    778              StoreAndDisRfInterrupt(Rex);
   \   000000   D2C32D00     BIC.B   #0x1, &0x2d
    779              
    780          	// Check cc1101 rx buffer free
    781              if(ptrRxBufWrite < ptrRxBufRead)
   \   000004   9292........ CMP.W   &ptrRxBufRead, &ptrRxBufWrite
   \   00000A   062C         JC      ??CC1101_Check_RxBuffer_Free_0
    782          	{
    783                  remain = ptrRxBufRead - ptrRxBufWrite - 1;
   \   00000C   1C42....     MOV.W   &ptrRxBufRead, R12
   \   000010   1C82....     SUB.W   &ptrRxBufWrite, R12
   \   000014   3C53         ADD.W   #0xffff, R12
   \   000016   073C         JMP     ??CC1101_Check_RxBuffer_Free_1
    784              }
    785              else
    786          	{
    787                  remain = RX_BUFFER_SIZE - (ptrRxBufWrite - ptrRxBufRead) - 1;
   \                     ??CC1101_Check_RxBuffer_Free_0:
   \   000018   3C401300     MOV.W   #0x13, R12
   \   00001C   1F42....     MOV.W   &ptrRxBufWrite, R15
   \   000020   1F82....     SUB.W   &ptrRxBufRead, R15
   \   000024   0C8F         SUB.W   R15, R12
    788          	}
    789              
    790              //enable rf rx interrupt 
    791              RestoreRfInterrupt(Rex);
   \                     ??CC1101_Check_RxBuffer_Free_1:
   \   000026   D2D32D00     BIS.B   #0x1, &0x2d
    792              
    793          	return remain;
   \   00002A   3041         RET
   \   00002C                REQUIRE P2IE
    794           }
    795          
    796          /* ======================================= *
    797           *    check RX rx receive data packet ?    *
    798           * ======================================= */

   \                                 In  segment CODE, align 2
    799           unsigned int CC1101_Check_Receive_Packet(void)
   \                     CC1101_Check_Receive_Packet:
    800           {
    801           //   unsigned char  Rex;
    802              unsigned int   length;
    803              //disable rf interrupt
    804              StoreAndDisRfInterrupt(Rex);
   \   000000   D2C32D00     BIC.B   #0x1, &0x2d
    805              
    806          	// Check Serial whether to receive data
    807              if(ptrRxBufWrite < ptrRxBufRead)
   \   000004   9292........ CMP.W   &ptrRxBufRead, &ptrRxBufWrite
   \   00000A   082C         JC      ??CC1101_Check_Receive_Packet_0
    808              {
    809                  length = RX_BUFFER_SIZE - (ptrRxBufRead - ptrRxBufWrite);
   \   00000C   3C401400     MOV.W   #0x14, R12
   \   000010   1F42....     MOV.W   &ptrRxBufRead, R15
   \   000014   1F82....     SUB.W   &ptrRxBufWrite, R15
   \   000018   0C8F         SUB.W   R15, R12
   \   00001A   043C         JMP     ??CC1101_Check_Receive_Packet_1
    810              }
    811              else
    812          	{
    813                  length = ptrRxBufWrite - ptrRxBufRead; 
   \                     ??CC1101_Check_Receive_Packet_0:
   \   00001C   1C42....     MOV.W   &ptrRxBufWrite, R12
   \   000020   1C82....     SUB.W   &ptrRxBufRead, R12
    814              }
    815              //enable rf rx interrupt 
    816              RestoreRfInterrupt(Rex);
   \                     ??CC1101_Check_Receive_Packet_1:
   \   000024   D2D32D00     BIS.B   #0x1, &0x2d
    817          	return length;
   \   000028   3041         RET
   \   00002A                REQUIRE P2IE
    818           }
    819           
    820          /* ============================================ *
    821           *       rf Erase the Packet of The length      *
    822           * ============================================ */

   \                                 In  segment CODE, align 2
    823           void CC1101_Erase_Buffer(unsigned int length)
   \                     CC1101_Erase_Buffer:
    824           {
    825          //	unsigned char  Rex;
    826              unsigned int   used;
    827              //disable rf interrupt
    828              StoreAndDisRfInterrupt(Rex);
   \   000000   D2C32D00     BIC.B   #0x1, &0x2d
    829              //需要擦除的大小必须小于等于写进去的长度
    830              if(ptrRxBufWrite < ptrRxBufRead)
   \   000004   9292........ CMP.W   &ptrRxBufRead, &ptrRxBufWrite
   \   00000A   082C         JC      ??CC1101_Erase_Buffer_1
    831              {
    832                  used = RX_BUFFER_SIZE - (ptrRxBufRead - ptrRxBufWrite);
   \   00000C   3F401400     MOV.W   #0x14, R15
   \   000010   1E42....     MOV.W   &ptrRxBufRead, R14
   \   000014   1E82....     SUB.W   &ptrRxBufWrite, R14
   \   000018   0F8E         SUB.W   R14, R15
   \   00001A   043C         JMP     ??CC1101_Erase_Buffer_2
    833              }
    834              else
    835              {
    836                  used = ptrRxBufWrite - ptrRxBufRead;
   \                     ??CC1101_Erase_Buffer_1:
   \   00001C   1F42....     MOV.W   &ptrRxBufWrite, R15
   \   000020   1F82....     SUB.W   &ptrRxBufRead, R15
    837              }
    838              length = (length > used)?used:length;
   \                     ??CC1101_Erase_Buffer_2:
   \   000024   0F9C         CMP.W   R12, R15
   \   000026   012C         JC      ??CC1101_Erase_Buffer_0
   \   000028   0C4F         MOV.W   R15, R12
    839              //erase .....
    840              ptrRxBufRead=((ptrRxBufRead+length)<ptrRxBufOver)?\
    841          	              (ptrRxBufRead+length):(ptrRxBufRead-(RX_BUFFER_SIZE-length));
   \                     ??CC1101_Erase_Buffer_0:
   \   00002A   1F42....     MOV.W   &ptrRxBufRead, R15
   \   00002E   0F5C         ADD.W   R12, R15
   \   000030   1F92....     CMP.W   &ptrRxBufOver, R15
   \   000034   032C         JC      ??CC1101_Erase_Buffer_3
   \   000036   825C....     ADD.W   R12, &ptrRxBufRead
   \   00003A   053C         JMP     ??CC1101_Erase_Buffer_4
   \                     ??CC1101_Erase_Buffer_3:
   \   00003C   3F401400     MOV.W   #0x14, R15
   \   000040   0F8C         SUB.W   R12, R15
   \   000042   828F....     SUB.W   R15, &ptrRxBufRead
    842          	//enable rf rx interrupt 
    843              RestoreRfInterrupt(Rex);
   \                     ??CC1101_Erase_Buffer_4:
   \   000046   D2D32D00     BIS.B   #0x1, &0x2d
    844           }
   \   00004A   3041         RET
   \   00004C                REQUIRE P2IE
    845          
    846          /* ============================================ *
    847           *           Get cc1101 rx data packet          *
    848           * ============================================ */

   \                                 In  segment CODE, align 2
    849           void CC1101_Get_Rx_Data(unsigned char *Dst,unsigned int length)
   \                     CC1101_Get_Rx_Data:
    850           {
    851              unsigned char  *pDst=Dst;
    852              unsigned int   i;
    853              for(i=0;i<length;i++)
   \   000000   0F43         MOV.W   #0x0, R15
   \   000002   0F3C         JMP     ??CC1101_Get_Rx_Data_1
    854              {
    855                  *pDst++ = *ptrRxBufRead++;
   \                     ??CC1101_Get_Rx_Data_0:
   \   000004   1E42....     MOV.W   &ptrRxBufRead, R14
   \   000008   EC4E0000     MOV.B   @R14, 0(R12)
   \   00000C   9253....     ADD.W   #0x1, &ptrRxBufRead
   \   000010   1C53         ADD.W   #0x1, R12
    856                  if(ptrRxBufRead == ptrRxBufOver)
   \   000012   9292........ CMP.W   &ptrRxBufOver, &ptrRxBufRead
   \   000018   0320         JNE     ??CC1101_Get_Rx_Data_2
    857                  {
    858                     ptrRxBufRead=&RxBuf[0];
   \   00001A   B240........ MOV.W   #RxBuf, &ptrRxBufRead
    859                  }
    860              }
   \                     ??CC1101_Get_Rx_Data_2:
   \   000020   1F53         ADD.W   #0x1, R15
   \                     ??CC1101_Get_Rx_Data_1:
   \   000022   0F9D         CMP.W   R13, R15
   \   000024   EF2B         JNC     ??CC1101_Get_Rx_Data_0
    861           }
   \   000026   3041         RET
    862           
    863          /* ============================================ *
    864           *        Get cc1101 current signal strong      *
    865           * ============================================ */

   \                                 In  segment CODE, align 2
    866           void CC1101_Get_Channel_RSSI(unsigned char *Rssi)
   \                     CC1101_Get_Channel_RSSI:
    867           {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    868              *Rssi = CC1101_Read_Status(cc1101_RSSI);
   \   000004   7C403400     MOV.B   #0x34, R12
   \   000008   B012....     CALL    #CC1101_Read_Status
   \   00000C   CA4C0000     MOV.B   R12, 0(R10)
    869           }
   \   000010   3A41         POP.W   R10
   \   000012   3041         RET
    870           
    871          /* ============================================ *
    872           *         Get cc1101 current signal LQI        *
    873           * ============================================ */

   \                                 In  segment CODE, align 2
    874           void CC1101_Get_Channel_LQI(unsigned char *Lqi)
   \                     CC1101_Get_Channel_LQI:
    875           {
   \   000000   0A12         PUSH.W  R10
   \   000002   0A4C         MOV.W   R12, R10
    876              *Lqi = CC1101_Read_Status(cc1101_LQI)&cc1101_CRC_OK;
   \   000004   7C403300     MOV.B   #0x33, R12
   \   000008   B012....     CALL    #CC1101_Read_Status
   \   00000C   7CF08000     AND.B   #0x80, R12
   \   000010   CA4C0000     MOV.B   R12, 0(R10)
    877           }
   \   000014   3A41         POP.W   R10
   \   000016   3041         RET
    878          
    879          /* ============================================ *
    880           *          RF cc1101 frequency adjust          *
    881           * ============================================ */ 

   \                                 In  segment CODE, align 2
    882           void CC1101_Frequency_Adjust(void)
   \                     CC1101_Frequency_Adjust:
    883           {
    884              //rf frequency scal 
    885              CC1101_Entry_XMode(Rf_Frq_Scal);
   \   000000   7C400500     MOV.B   #0x5, R12
   \   000004   B012....     CALL    #CC1101_Entry_XMode
    886              //rx mode after tx 
    887              CC1101_Entry_XMode(Rf_Rx_Mode);
   \   000008   4C43         MOV.B   #0x0, R12
   \   00000A   3040....     BR      #CC1101_Entry_XMode
    888           }
    889           
    890          /* ============================================ *
    891           *               RF cc1101 Routine              *
    892           * ============================================ */

   \                                 In  segment CODE, align 2
    893           void CC1101_Routine_Check(void)
   \                     CC1101_Routine_Check:
    894           {
   \   000000   0A12         PUSH.W  R10
    895              RoutineCounter += 1;
   \   000002   D253....     ADD.B   #0x1, &RoutineCounter
    896              if(RoutineCounter < CC1101_ROUTINE_CHECK_COUTER)
   \   000006   E292....     CMP.B   #0x4, &RoutineCounter
   \   00000A   272C         JC      ??CC1101_Routine_Check_1
    897              {
    898          //        unsigned char   Rex;
    899                  unsigned char   status;
    900                  //disable rf interrupt
    901                  StoreAndDisRfInterrupt(Rex);
   \   00000C   D2C32D00     BIC.B   #0x1, &0x2d
    902                  //enable cc1101
    903          	    Enable_CC1101;
   \   000010   F2C020002100 BIC.B   #0x20, &0x21
    904                  //wait for ....
    905          	    while(CC1101_Check_So);
   \                     ??CC1101_Routine_Check_0:
   \   000016   E2B32000     BIT.B   #0x2, &0x20
   \   00001A   FD2F         JC      ??CC1101_Routine_Check_0
    906                  //get cc1101 status
    907                  status = spi_readwrite(0xff);
   \   00001C   7C43         MOV.B   #0xff, R12
   \   00001E   B012....     CALL    #spi_readwrite
   \   000022   4A4C         MOV.B   R12, R10
    908          	    //disable cc1101
    909          	    Disable_CC1101;
   \   000024   F2D020002100 BIS.B   #0x20, &0x21
    910          
    911                  //检查发送是否溢出
    912          	    if(CHECK_TXFIFO(status) == TX_OVERFLOW)
   \   00002A   4E4A         MOV.B   R10, R14
   \   00002C   7EF07000     AND.B   #0x70, R14
   \   000030   7E907000     CMP.B   #0x70, R14
   \   000034   0420         JNE     ??CC1101_Routine_Check_2
    913          	    {
    914          	        //清洗发送缓冲区
    915          	        CC1101_Strobe(cc1101_SFTX);  
   \   000036   7C403B00     MOV.B   #0x3b, R12
   \   00003A   B012....     CALL    #CC1101_Strobe
    916                  }
    917          	    if((CHECK_RXFIFO(status) == RX_OVERFLOW))
   \                     ??CC1101_Routine_Check_2:
   \   00003E   7AF06000     AND.B   #0x60, R10
   \   000042   7A906000     CMP.B   #0x60, R10
   \   000046   0420         JNE     ??CC1101_Routine_Check_3
    918            	    {
    919          	        //清空接收缓冲区
    920          	        CC1101_Strobe(cc1101_SFRX); 
   \   000048   7C403A00     MOV.B   #0x3a, R12
   \   00004C   B012....     CALL    #CC1101_Strobe
    921             	    }
    922           
    923                  //RF cc1101 frequency adjust
    924                  CC1101_Frequency_Adjust();
   \                     ??CC1101_Routine_Check_3:
   \   000050   B012....     CALL    #CC1101_Frequency_Adjust
    925          
    926                  //enable rf rx interrupt
    927                  RestoreRfInterrupt(Rex);
   \   000054   D2D32D00     BIS.B   #0x1, &0x2d
   \   000058   073C         JMP     ??CC1101_Routine_Check_4
    928                  
    929              }
    930              else
    931              {
    932                  RoutineCounter = 0;
   \                     ??CC1101_Routine_Check_1:
   \   00005A   C243....     MOV.B   #0x0, &RoutineCounter
    933          	    if(pRfResetCallBack != NULL)
   \   00005E   8293....     CMP.W   #0x0, &pRfResetCallBack
   \   000062   0224         JEQ     ??CC1101_Routine_Check_4
    934                  {
    935                     pRfResetCallBack();
   \   000064   9212....     CALL    &pRfResetCallBack
    936                  }
    937              }    
    938           }
   \                     ??CC1101_Routine_Check_4:
   \   000068   3A41         POP.W   R10
   \   00006A   3041         RET
   \   00006C                REQUIRE P2IE
   \   00006C                REQUIRE P1OUT
   \   00006C                REQUIRE P1IN

   \                                 In  segment DATA16_ID, align 1, align-sorted
   \                     `?<Initializer for dat>`:
   \   000000   B101         DC8 177, 1

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
       2  CC1101_CarrierSense_Threshold
            2 -> CC1101_Write_Reg
       2  CC1101_Check_Receive_Packet
       2  CC1101_Check_RxBuffer_Free
       2  CC1101_Config_Gpio0
            2 -> CC1101_Write_Reg
       2  CC1101_Config_Gpio2
            2 -> CC1101_Write_Reg
       2  CC1101_Config_Pins
       2  CC1101_EnterIntoSleepMode
            2 -> CC1101_Entry_XMode
       4  CC1101_Entry_XMode
            4 -> CC1101_Strobe
       2  CC1101_Erase_Buffer
       2  CC1101_Frequency_Adjust
            2 -> CC1101_Entry_XMode
       4  CC1101_Get_Channel_LQI
            4 -> CC1101_Read_Status
       4  CC1101_Get_Channel_RSSI
            4 -> CC1101_Read_Status
       2  CC1101_Get_Rx_Data
       2  CC1101_Initialization
            2 -> CC1101_CarrierSense_Threshold
            2 -> CC1101_Config_Gpio0
            2 -> CC1101_Config_Gpio2
            2 -> CC1101_Config_Pins
            2 -> CC1101_Entry_XMode
            2 -> CC1101_Interrupt_Config
            2 -> CC1101_Power_Up
            2 -> CC1101_Read_Reg
            2 -> CC1101_Rf_Write_Settings
            2 -> CC1101_Select_Transmit_Power_Level
            2 -> CC1101_Setting_Address
            2 -> CC1101_Setting_Channel
            2 -> CC1101_Setting_FreSection
            2 -> CC1101_Setting_SynchHead
       2  CC1101_Interrupt_Config
       2  CC1101_Power_Up
            2 -> _delay_us
            2 -> spi_readwrite
       2  CC1101_Read_Burst_Reg
            2 -> spi_readwrite
       2  CC1101_Read_Packet
            2 -> CC1101_Check_RxBuffer_Free
            2 -> CC1101_Read_Burst_Reg
       2  CC1101_Read_Reg
            2 -> spi_readwrite
       2  CC1101_Read_Status
            2 -> spi_readwrite
       2  CC1101_Receive_Packet
            2 -> CC1101_Entry_XMode
            2 -> CC1101_Read_Packet
            2 -> CC1101_Read_Reg
            2 -> CC1101_Read_Status
       2  CC1101_ResetCallBackRegister
       2  CC1101_Rf_Write_Settings
            2 -> CC1101_Write_Reg
       4  CC1101_Routine_Check
            4 -- Indirect call
            4 -> CC1101_Frequency_Adjust
            4 -> CC1101_Strobe
            4 -> spi_readwrite
       2  CC1101_RxBuffer_Initial
       2  CC1101_Select_Transmit_Power_Level
            2 -> CC1101_Setting_Power
       2  CC1101_Send_Packet
            2 -> CC1101_Entry_XMode
       2  CC1101_Setting_Address
            2 -> CC1101_Write_Reg
       2  CC1101_Setting_Channel
            2 -> CC1101_Write_Reg
       2  CC1101_Setting_FreSection
            2 -> CC1101_Write_Reg
       6  CC1101_Setting_Power
            6 -> spi_readwrite
       2  CC1101_Setting_SynchHead
            2 -> CC1101_Write_Reg
       2  CC1101_Strobe
            2 -> spi_readwrite
       2  CC1101_WakeUpToIdleMode
            2 -> CC1101_Entry_XMode
            2 -> _delay_us
       6  CC1101_Write_Burst_Reg
            6 -> spi_readwrite
            6 -> spi_write_buf
       6  CC1101_Write_Fifo
            6 -> CC1101_Write_Burst_Reg
            6 -> CC1101_Write_Reg
       4  CC1101_Write_Reg
            4 -> spi_readwrite
       2  _delay_us


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for dat>
     128  CC1101_CarrierSense_Threshold
      42  CC1101_Check_Receive_Packet
      44  CC1101_Check_RxBuffer_Free
       8  CC1101_Config_Gpio0
       8  CC1101_Config_Gpio2
      50  CC1101_Config_Pins
       6  CC1101_EnterIntoSleepMode
     134  CC1101_Entry_XMode
      76  CC1101_Erase_Buffer
      14  CC1101_Frequency_Adjust
      24  CC1101_Get_Channel_LQI
      20  CC1101_Get_Channel_RSSI
      40  CC1101_Get_Rx_Data
     116  CC1101_Initialization
      18  CC1101_Interrupt_Config
      62  CC1101_Power_Up
      34  CC1101_Read_Burst_Reg
      48  CC1101_Read_Packet
      42  CC1101_Read_Reg
      42  CC1101_Read_Status
      40  CC1101_Receive_Packet
       6  CC1101_ResetCallBackRegister
     312  CC1101_Rf_Write_Settings
     108  CC1101_Routine_Check
      14  CC1101_RxBuffer_Initial
     122  CC1101_Select_Transmit_Power_Level
      54  CC1101_Send_Packet
      10  CC1101_Setting_Address
      10  CC1101_Setting_Channel
     198  CC1101_Setting_FreSection
      54  CC1101_Setting_Power
      22  CC1101_Setting_SynchHead
      24  CC1101_Strobe
      28  CC1101_WakeUpToIdleMode
      56  CC1101_Write_Burst_Reg
      44  CC1101_Write_Fifo
      44  CC1101_Write_Reg
       1  P1DIR
       1  P1IN
       1  P1OUT
       1  P2DIR
       1  P2IE
       1  P2IES
       1  P2IFG
       1  P2IN
       1  RoutineCounter
      20  RxBuf
      36  _delay_us
       2  dat
       2  pRfResetCallBack
       2  ptrRxBufOver
       2  ptrRxBufRead
       2  ptrRxBufWrite
       1  sys_send

 
 2 138 bytes in segment CODE
     8 bytes in segment DATA16_AN
     2 bytes in segment DATA16_C
     2 bytes in segment DATA16_I
     2 bytes in segment DATA16_ID
    28 bytes in segment DATA16_Z
 
 2 138 bytes of CODE  memory
     4 bytes of CONST memory
    30 bytes of DATA  memory (+ 8 bytes shared)

Errors: none
Warnings: none
